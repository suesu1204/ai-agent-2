import traceback

from langgraph.errors import GraphInterrupt, ParentCommand
from langgraph.types import Interrupt

from langgraph_grpc_common import serde
from langgraph_grpc_common.conversion.value import (
    any_to_serialized_value,
    command_to_proto,
)
from langgraph_grpc_common.proto import engine_common_pb2, errors_pb2


def exception_to_proto(
    exc: Exception,
) -> (
    errors_pb2.UserCodeExecutionError
    | engine_common_pb2.WrappedInterrupts
    | engine_common_pb2.ParentCommand
):
    if isinstance(exc, GraphInterrupt):
        if exc.args[0]:
            # Serialize the list of Interrupts
            encoding, ser = serde.get_serializer().dumps_typed(exc.args[0])
            serialized_interrupts = engine_common_pb2.SerializedValue(
                encoding=encoding, value=ser
            )
            interrupts = interrupts_to_proto(exc.args[0])
            return engine_common_pb2.WrappedInterrupts(
                interrupts=interrupts, serialized_interrupts=serialized_interrupts
            )
        else:
            # Static interrupt (interrupt_before or interrupt_after)
            return engine_common_pb2.WrappedInterrupts(
                interrupts=[engine_common_pb2.Interrupt()]
            )
    elif isinstance(exc, ParentCommand):
        cmd = exc.args[0]
        return engine_common_pb2.ParentCommand(command=command_to_proto(cmd))
    else:
        return errors_pb2.UserCodeExecutionError(
            error_type=exc.__class__.__name__,
            error_message=str(exc),
            traceback=traceback.format_exc(),
        )


def interrupts_to_proto(
    interrupts: tuple[Interrupt],
) -> list[engine_common_pb2.Interrupt]:
    return [
        engine_common_pb2.Interrupt(
            value=any_to_serialized_value(interrupt.value),
            id=interrupt.id,  # type: ignore[unresolved-attribute]
        )
        for interrupt in interrupts
    ]
