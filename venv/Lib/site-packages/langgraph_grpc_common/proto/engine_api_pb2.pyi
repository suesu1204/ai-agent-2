"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

from collections import abc as _abc
from google.protobuf import descriptor as _descriptor
from google.protobuf import empty_pb2 as _empty_pb2
from google.protobuf import message as _message
from google.protobuf import timestamp_pb2 as _timestamp_pb2
from google.protobuf.internal import containers as _containers
import builtins as _builtins
from . import engine_common_pb2 as _engine_common_pb2
from . import enum_durability_pb2 as _enum_durability_pb2
from . import enum_store_operation_entry_type_pb2 as _enum_store_operation_entry_type_pb2
from . import enum_stream_mode_pb2 as _enum_stream_mode_pb2
from . import errors_pb2 as _errors_pb2
import sys
import typing as _typing

if sys.version_info >= (3, 10):
    from typing import TypeAlias as _TypeAlias
else:
    from typing_extensions import TypeAlias as _TypeAlias

DESCRIPTOR: _descriptor.FileDescriptor

@_typing.final
class InvokeRequest(_message.Message):
    """Invoke request"""

    DESCRIPTOR: _descriptor.Descriptor

    GRAPH_ID_FIELD_NUMBER: _builtins.int
    INPUT_FIELD_NUMBER: _builtins.int
    CONFIG_FIELD_NUMBER: _builtins.int
    LANGGRAPH_CONTEXT_JSON_FIELD_NUMBER: _builtins.int
    OUTPUT_KEYS_FIELD_NUMBER: _builtins.int
    INTERRUPT_BEFORE_FIELD_NUMBER: _builtins.int
    INTERRUPT_AFTER_FIELD_NUMBER: _builtins.int
    DURABILITY_FIELD_NUMBER: _builtins.int
    DEBUG_FIELD_NUMBER: _builtins.int
    STREAM_SUBGRAPHS_FIELD_NUMBER: _builtins.int
    STREAM_MODES_FIELD_NUMBER: _builtins.int
    STREAM_MODE_SINGLE_FIELD_NUMBER: _builtins.int
    graph_id: _builtins.str
    langgraph_context_json: _builtins.bytes
    """NOTE: only json encoding is supported because this is the encoding in persistence(jsonb column type)"""
    durability: _enum_durability_pb2.Durability.ValueType
    debug: _builtins.bool
    stream_subgraphs: _builtins.bool
    """Whether to include streaming content (messages, events, etc.) from nested
    subgraphs in the output stream. For nested events, this also modifies the event name to include
    the task namespace (e.g. `messages|subagentfoo<abcd>|subagentbar<efgh>`)
    """
    stream_mode_single: _builtins.bool
    """Whether the stream_mode was passed as a single string (true) or as a list/sequence (false).
    This affects the output format to match OSS LangGraph behavior:
    - single string (true): returns just payload
    - list (false/default): always returns tuples (mode, payload) even if only one mode
    """
    @_builtins.property
    def input(self) -> Global___RunInput:
        """NOTE: when input is nil, it's resuming as a legacy feature"""

    @_builtins.property
    def config(self) -> _engine_common_pb2.EngineRunnableConfig: ...
    @_builtins.property
    def output_keys(self) -> _engine_common_pb2.StringOrSlice:
        """we need StringOrSlice here, because output_keys=["a"] will have different behavior than output_keys="a" """

    @_builtins.property
    def interrupt_before(self) -> _engine_common_pb2.StaticInterruptConfig: ...
    @_builtins.property
    def interrupt_after(self) -> _engine_common_pb2.StaticInterruptConfig: ...
    @_builtins.property
    def stream_modes(self) -> _containers.RepeatedScalarFieldContainer[_enum_stream_mode_pb2.StreamMode.ValueType]: ...
    def __init__(
        self,
        *,
        graph_id: _builtins.str = ...,
        input: Global___RunInput | None = ...,
        config: _engine_common_pb2.EngineRunnableConfig | None = ...,
        langgraph_context_json: _builtins.bytes | None = ...,
        output_keys: _engine_common_pb2.StringOrSlice | None = ...,
        interrupt_before: _engine_common_pb2.StaticInterruptConfig | None = ...,
        interrupt_after: _engine_common_pb2.StaticInterruptConfig | None = ...,
        durability: _enum_durability_pb2.Durability.ValueType | None = ...,
        debug: _builtins.bool | None = ...,
        stream_subgraphs: _builtins.bool | None = ...,
        stream_modes: _abc.Iterable[_enum_stream_mode_pb2.StreamMode.ValueType] | None = ...,
        stream_mode_single: _builtins.bool | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["_debug", b"_debug", "_durability", b"_durability", "_input", b"_input", "_interrupt_after", b"_interrupt_after", "_interrupt_before", b"_interrupt_before", "_langgraph_context_json", b"_langgraph_context_json", "_output_keys", b"_output_keys", "_stream_mode_single", b"_stream_mode_single", "_stream_subgraphs", b"_stream_subgraphs", "config", b"config", "debug", b"debug", "durability", b"durability", "input", b"input", "interrupt_after", b"interrupt_after", "interrupt_before", b"interrupt_before", "langgraph_context_json", b"langgraph_context_json", "output_keys", b"output_keys", "stream_mode_single", b"stream_mode_single", "stream_subgraphs", b"stream_subgraphs"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["_debug", b"_debug", "_durability", b"_durability", "_input", b"_input", "_interrupt_after", b"_interrupt_after", "_interrupt_before", b"_interrupt_before", "_langgraph_context_json", b"_langgraph_context_json", "_output_keys", b"_output_keys", "_stream_mode_single", b"_stream_mode_single", "_stream_subgraphs", b"_stream_subgraphs", "config", b"config", "debug", b"debug", "durability", b"durability", "graph_id", b"graph_id", "input", b"input", "interrupt_after", b"interrupt_after", "interrupt_before", b"interrupt_before", "langgraph_context_json", b"langgraph_context_json", "output_keys", b"output_keys", "stream_mode_single", b"stream_mode_single", "stream_modes", b"stream_modes", "stream_subgraphs", b"stream_subgraphs"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType__debug: _TypeAlias = _typing.Literal["debug"]  # noqa: Y015
    _WhichOneofArgType__debug: _TypeAlias = _typing.Literal["_debug", b"_debug"]  # noqa: Y015
    _WhichOneofReturnType__durability: _TypeAlias = _typing.Literal["durability"]  # noqa: Y015
    _WhichOneofArgType__durability: _TypeAlias = _typing.Literal["_durability", b"_durability"]  # noqa: Y015
    _WhichOneofReturnType__input: _TypeAlias = _typing.Literal["input"]  # noqa: Y015
    _WhichOneofArgType__input: _TypeAlias = _typing.Literal["_input", b"_input"]  # noqa: Y015
    _WhichOneofReturnType__interrupt_after: _TypeAlias = _typing.Literal["interrupt_after"]  # noqa: Y015
    _WhichOneofArgType__interrupt_after: _TypeAlias = _typing.Literal["_interrupt_after", b"_interrupt_after"]  # noqa: Y015
    _WhichOneofReturnType__interrupt_before: _TypeAlias = _typing.Literal["interrupt_before"]  # noqa: Y015
    _WhichOneofArgType__interrupt_before: _TypeAlias = _typing.Literal["_interrupt_before", b"_interrupt_before"]  # noqa: Y015
    _WhichOneofReturnType__langgraph_context_json: _TypeAlias = _typing.Literal["langgraph_context_json"]  # noqa: Y015
    _WhichOneofArgType__langgraph_context_json: _TypeAlias = _typing.Literal["_langgraph_context_json", b"_langgraph_context_json"]  # noqa: Y015
    _WhichOneofReturnType__output_keys: _TypeAlias = _typing.Literal["output_keys"]  # noqa: Y015
    _WhichOneofArgType__output_keys: _TypeAlias = _typing.Literal["_output_keys", b"_output_keys"]  # noqa: Y015
    _WhichOneofReturnType__stream_mode_single: _TypeAlias = _typing.Literal["stream_mode_single"]  # noqa: Y015
    _WhichOneofArgType__stream_mode_single: _TypeAlias = _typing.Literal["_stream_mode_single", b"_stream_mode_single"]  # noqa: Y015
    _WhichOneofReturnType__stream_subgraphs: _TypeAlias = _typing.Literal["stream_subgraphs"]  # noqa: Y015
    _WhichOneofArgType__stream_subgraphs: _TypeAlias = _typing.Literal["_stream_subgraphs", b"_stream_subgraphs"]  # noqa: Y015
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__debug) -> _WhichOneofReturnType__debug | None: ...
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__durability) -> _WhichOneofReturnType__durability | None: ...
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__input) -> _WhichOneofReturnType__input | None: ...
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__interrupt_after) -> _WhichOneofReturnType__interrupt_after | None: ...
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__interrupt_before) -> _WhichOneofReturnType__interrupt_before | None: ...
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__langgraph_context_json) -> _WhichOneofReturnType__langgraph_context_json | None: ...
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__output_keys) -> _WhichOneofReturnType__output_keys | None: ...
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__stream_mode_single) -> _WhichOneofReturnType__stream_mode_single | None: ...
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__stream_subgraphs) -> _WhichOneofReturnType__stream_subgraphs | None: ...

Global___InvokeRequest: _TypeAlias = InvokeRequest  # noqa: Y015

@_typing.final
class RunInput(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    INPUT_FIELD_NUMBER: _builtins.int
    COMMAND_FIELD_NUMBER: _builtins.int
    @_builtins.property
    def input(self) -> _engine_common_pb2.SerializedValue: ...
    @_builtins.property
    def command(self) -> _engine_common_pb2.Command: ...
    def __init__(
        self,
        *,
        input: _engine_common_pb2.SerializedValue | None = ...,
        command: _engine_common_pb2.Command | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["command", b"command", "input", b"input", "val", b"val"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["command", b"command", "input", b"input", "val", b"val"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType_val: _TypeAlias = _typing.Literal["input", "command"]  # noqa: Y015
    _WhichOneofArgType_val: _TypeAlias = _typing.Literal["val", b"val"]  # noqa: Y015
    def WhichOneof(self, oneof_group: _WhichOneofArgType_val) -> _WhichOneofReturnType_val | None: ...

Global___RunInput: _TypeAlias = RunInput  # noqa: Y015

@_typing.final
class InvokeResponse(_message.Message):
    """InvokeResponse represents the result of an `Invoke` call to the Pregel engine.

    The `invoke` API internally delegates to Pregel's `stream` method, consuming the full
    stream and returning a single consolidated response when the run completes.
    By default, "values" stream mode is assumed, meaning only the final `values`
    event is returned (via `single_output`).
    """

    DESCRIPTOR: _descriptor.Descriptor

    CHUNK_LIST_FIELD_NUMBER: _builtins.int
    USER_ERROR_FIELD_NUMBER: _builtins.int
    EMPTY_FIELD_NUMBER: _builtins.int
    UNSUPPRESSED_INTERRUPT_ERROR_FIELD_NUMBER: _builtins.int
    SINGLE_OUTPUT_FIELD_NUMBER: _builtins.int
    RECURSION_LIMIT_FIELD_NUMBER: _builtins.int
    PARENT_COMMAND_FIELD_NUMBER: _builtins.int
    @_builtins.property
    def chunk_list(self) -> _engine_common_pb2.ResponseChunkList:
        """Aggregated list of streamed events collected during the run.

        This field is used when the caller specifies one or more stream modes
        beyond the default "values" mode (for example, "updates" or "messages").
        Each element in the list corresponds to an event emitted by the engine
        and appears in the same order they were produced in the underlying stream.

        In effect, `chunk_list` represents a batched form of the streaming API
        output, allowing `invoke` to return multiple event types in a single
        response.
        NOTE: graphInterrupts are represented in the ResponseChunk with special key "__interrupt__"
        of updates event
        """

    @_builtins.property
    def user_error(self) -> _errors_pb2.UserCodeExecutionError:
        """Error that occurred within the executor during run execution
        (as opposed to internal errors occurring in the engine itself, or graphInterrupts).
        """

    @_builtins.property
    def empty(self) -> _empty_pb2.Empty: ...
    @_builtins.property
    def unsuppressed_interrupt_error(self) -> _engine_common_pb2.GraphInterrupt:
        """Represents the "unsuppressed" graph-level interrupts(one or more)

        Interrupts occur when tasks suspend (for example, awaiting user confirmation).
        Each interrupt contains the affected task ID and
        optional payload prompting the user for a response. Clients can
        later resume execution by providing a value for the interruptâ€™s task ID.

        Normally the interrupts are suppressed and returned as part of the regular response (chunk_list or single_output)
        This is for unsuppressed interrupts, currently in case of interrupts from subGraph, the interrupts are
        returned directly so that it can be handled by client directly.
        TODO: maybe we should never suppress and always return interrupts with output, and let executor handle it?
        """

    @_builtins.property
    def single_output(self) -> _engine_common_pb2.SerializedValue:
        """Single serialized output representing the final `values` event in the underlying stream.

        This is the default return as "values" mode, when a run executes successfully and without interruption.
        """

    @_builtins.property
    def recursion_limit(self) -> _errors_pb2.GraphRecursionLimitError:
        """Indicates the graph exceeded its configured recursion limit.
        Carries the limit value so clients can surface it without relying on error parsing.
        """

    @_builtins.property
    def parent_command(self) -> _engine_common_pb2.ParentCommand:
        """Contains the Command to be propagated to the parent graph.

        Returned when a node returns Command(graph=Command.PARENT).
        """

    def __init__(
        self,
        *,
        chunk_list: _engine_common_pb2.ResponseChunkList | None = ...,
        user_error: _errors_pb2.UserCodeExecutionError | None = ...,
        empty: _empty_pb2.Empty | None = ...,
        unsuppressed_interrupt_error: _engine_common_pb2.GraphInterrupt | None = ...,
        single_output: _engine_common_pb2.SerializedValue | None = ...,
        recursion_limit: _errors_pb2.GraphRecursionLimitError | None = ...,
        parent_command: _engine_common_pb2.ParentCommand | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["chunk_list", b"chunk_list", "empty", b"empty", "parent_command", b"parent_command", "recursion_limit", b"recursion_limit", "single_output", b"single_output", "unsuppressed_interrupt_error", b"unsuppressed_interrupt_error", "user_error", b"user_error", "value", b"value"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["chunk_list", b"chunk_list", "empty", b"empty", "parent_command", b"parent_command", "recursion_limit", b"recursion_limit", "single_output", b"single_output", "unsuppressed_interrupt_error", b"unsuppressed_interrupt_error", "user_error", b"user_error", "value", b"value"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType_value: _TypeAlias = _typing.Literal["chunk_list", "user_error", "empty", "unsuppressed_interrupt_error", "single_output", "recursion_limit", "parent_command"]  # noqa: Y015
    _WhichOneofArgType_value: _TypeAlias = _typing.Literal["value", b"value"]  # noqa: Y015
    def WhichOneof(self, oneof_group: _WhichOneofArgType_value) -> _WhichOneofReturnType_value | None: ...

Global___InvokeResponse: _TypeAlias = InvokeResponse  # noqa: Y015

@_typing.final
class StreamRequest(_message.Message):
    """Stream request"""

    DESCRIPTOR: _descriptor.Descriptor

    GRAPH_ID_FIELD_NUMBER: _builtins.int
    INPUT_FIELD_NUMBER: _builtins.int
    CONFIG_FIELD_NUMBER: _builtins.int
    LANGGRAPH_CONTEXT_JSON_FIELD_NUMBER: _builtins.int
    OUTPUT_KEYS_FIELD_NUMBER: _builtins.int
    INTERRUPT_BEFORE_FIELD_NUMBER: _builtins.int
    INTERRUPT_AFTER_FIELD_NUMBER: _builtins.int
    DURABILITY_FIELD_NUMBER: _builtins.int
    DEBUG_FIELD_NUMBER: _builtins.int
    STREAM_SUBGRAPHS_FIELD_NUMBER: _builtins.int
    STREAM_MODES_FIELD_NUMBER: _builtins.int
    STREAM_MODE_SINGLE_FIELD_NUMBER: _builtins.int
    graph_id: _builtins.str
    langgraph_context_json: _builtins.bytes
    """NOTE: only json encoding is supported because this is the encoding in persistence(jsonb column type)"""
    durability: _enum_durability_pb2.Durability.ValueType
    debug: _builtins.bool
    stream_subgraphs: _builtins.bool
    """Whether to include streaming content (messages, events, etc.) from nested
    subgraphs in the output stream. For nested events, this also modifies the event name to include
    the task namespace (e.g. `messages|subagentfoo<abcd>|subagentbar<efgh>`)
    """
    stream_mode_single: _builtins.bool
    """Whether the stream_mode was passed as a single string (true) or as a list/sequence (false).
    This affects the output format to match OSS LangGraph behavior:
    - single string (true): returns just payload
    - list (false/default): always returns tuples (mode, payload) even if only one mode
    """
    @_builtins.property
    def input(self) -> Global___RunInput:
        """NOTE: when input is nil, it's resuming as a legacy feature"""

    @_builtins.property
    def config(self) -> _engine_common_pb2.EngineRunnableConfig: ...
    @_builtins.property
    def output_keys(self) -> _engine_common_pb2.StringOrSlice: ...
    @_builtins.property
    def interrupt_before(self) -> _engine_common_pb2.StaticInterruptConfig: ...
    @_builtins.property
    def interrupt_after(self) -> _engine_common_pb2.StaticInterruptConfig: ...
    @_builtins.property
    def stream_modes(self) -> _containers.RepeatedScalarFieldContainer[_enum_stream_mode_pb2.StreamMode.ValueType]: ...
    def __init__(
        self,
        *,
        graph_id: _builtins.str = ...,
        input: Global___RunInput | None = ...,
        config: _engine_common_pb2.EngineRunnableConfig | None = ...,
        langgraph_context_json: _builtins.bytes | None = ...,
        output_keys: _engine_common_pb2.StringOrSlice | None = ...,
        interrupt_before: _engine_common_pb2.StaticInterruptConfig | None = ...,
        interrupt_after: _engine_common_pb2.StaticInterruptConfig | None = ...,
        durability: _enum_durability_pb2.Durability.ValueType | None = ...,
        debug: _builtins.bool | None = ...,
        stream_subgraphs: _builtins.bool | None = ...,
        stream_modes: _abc.Iterable[_enum_stream_mode_pb2.StreamMode.ValueType] | None = ...,
        stream_mode_single: _builtins.bool | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["_debug", b"_debug", "_durability", b"_durability", "_input", b"_input", "_interrupt_after", b"_interrupt_after", "_interrupt_before", b"_interrupt_before", "_langgraph_context_json", b"_langgraph_context_json", "_output_keys", b"_output_keys", "_stream_mode_single", b"_stream_mode_single", "_stream_subgraphs", b"_stream_subgraphs", "config", b"config", "debug", b"debug", "durability", b"durability", "input", b"input", "interrupt_after", b"interrupt_after", "interrupt_before", b"interrupt_before", "langgraph_context_json", b"langgraph_context_json", "output_keys", b"output_keys", "stream_mode_single", b"stream_mode_single", "stream_subgraphs", b"stream_subgraphs"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["_debug", b"_debug", "_durability", b"_durability", "_input", b"_input", "_interrupt_after", b"_interrupt_after", "_interrupt_before", b"_interrupt_before", "_langgraph_context_json", b"_langgraph_context_json", "_output_keys", b"_output_keys", "_stream_mode_single", b"_stream_mode_single", "_stream_subgraphs", b"_stream_subgraphs", "config", b"config", "debug", b"debug", "durability", b"durability", "graph_id", b"graph_id", "input", b"input", "interrupt_after", b"interrupt_after", "interrupt_before", b"interrupt_before", "langgraph_context_json", b"langgraph_context_json", "output_keys", b"output_keys", "stream_mode_single", b"stream_mode_single", "stream_modes", b"stream_modes", "stream_subgraphs", b"stream_subgraphs"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType__debug: _TypeAlias = _typing.Literal["debug"]  # noqa: Y015
    _WhichOneofArgType__debug: _TypeAlias = _typing.Literal["_debug", b"_debug"]  # noqa: Y015
    _WhichOneofReturnType__durability: _TypeAlias = _typing.Literal["durability"]  # noqa: Y015
    _WhichOneofArgType__durability: _TypeAlias = _typing.Literal["_durability", b"_durability"]  # noqa: Y015
    _WhichOneofReturnType__input: _TypeAlias = _typing.Literal["input"]  # noqa: Y015
    _WhichOneofArgType__input: _TypeAlias = _typing.Literal["_input", b"_input"]  # noqa: Y015
    _WhichOneofReturnType__interrupt_after: _TypeAlias = _typing.Literal["interrupt_after"]  # noqa: Y015
    _WhichOneofArgType__interrupt_after: _TypeAlias = _typing.Literal["_interrupt_after", b"_interrupt_after"]  # noqa: Y015
    _WhichOneofReturnType__interrupt_before: _TypeAlias = _typing.Literal["interrupt_before"]  # noqa: Y015
    _WhichOneofArgType__interrupt_before: _TypeAlias = _typing.Literal["_interrupt_before", b"_interrupt_before"]  # noqa: Y015
    _WhichOneofReturnType__langgraph_context_json: _TypeAlias = _typing.Literal["langgraph_context_json"]  # noqa: Y015
    _WhichOneofArgType__langgraph_context_json: _TypeAlias = _typing.Literal["_langgraph_context_json", b"_langgraph_context_json"]  # noqa: Y015
    _WhichOneofReturnType__output_keys: _TypeAlias = _typing.Literal["output_keys"]  # noqa: Y015
    _WhichOneofArgType__output_keys: _TypeAlias = _typing.Literal["_output_keys", b"_output_keys"]  # noqa: Y015
    _WhichOneofReturnType__stream_mode_single: _TypeAlias = _typing.Literal["stream_mode_single"]  # noqa: Y015
    _WhichOneofArgType__stream_mode_single: _TypeAlias = _typing.Literal["_stream_mode_single", b"_stream_mode_single"]  # noqa: Y015
    _WhichOneofReturnType__stream_subgraphs: _TypeAlias = _typing.Literal["stream_subgraphs"]  # noqa: Y015
    _WhichOneofArgType__stream_subgraphs: _TypeAlias = _typing.Literal["_stream_subgraphs", b"_stream_subgraphs"]  # noqa: Y015
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__debug) -> _WhichOneofReturnType__debug | None: ...
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__durability) -> _WhichOneofReturnType__durability | None: ...
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__input) -> _WhichOneofReturnType__input | None: ...
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__interrupt_after) -> _WhichOneofReturnType__interrupt_after | None: ...
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__interrupt_before) -> _WhichOneofReturnType__interrupt_before | None: ...
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__langgraph_context_json) -> _WhichOneofReturnType__langgraph_context_json | None: ...
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__output_keys) -> _WhichOneofReturnType__output_keys | None: ...
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__stream_mode_single) -> _WhichOneofReturnType__stream_mode_single | None: ...
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__stream_subgraphs) -> _WhichOneofReturnType__stream_subgraphs | None: ...

Global___StreamRequest: _TypeAlias = StreamRequest  # noqa: Y015

@_typing.final
class StreamOutputChunk(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    CHUNK_FIELD_NUMBER: _builtins.int
    USER_ERROR_FIELD_NUMBER: _builtins.int
    CHAT_MESSAGE_FIELD_NUMBER: _builtins.int
    RECURSION_LIMIT_FIELD_NUMBER: _builtins.int
    UNSUPPRESSED_INTERRUPT_ERROR_FIELD_NUMBER: _builtins.int
    @_builtins.property
    def chunk(self) -> _engine_common_pb2.ResponseChunk:
        """a single streaming output chunk
        which contain the mode, namespace and payload.
        Note: the payload could be a map that has graphInterrupt
        """

    @_builtins.property
    def user_error(self) -> _errors_pb2.UserCodeExecutionError:
        """Error that occurred within the executor during run execution
        (as opposed to internal errors occurring in the engine itself, or graphInterrupts).
        """

    @_builtins.property
    def chat_message(self) -> _engine_common_pb2.ChatMessageEnvelope:
        """specialised for chat streaming"""

    @_builtins.property
    def recursion_limit(self) -> _errors_pb2.GraphRecursionLimitError:
        """Indicates the graph exceeded its configured recursion limit while streaming."""

    @_builtins.property
    def unsuppressed_interrupt_error(self) -> _engine_common_pb2.GraphInterrupt:
        """Unsuppressed graph interrupt from a nested subgraph.
        When a subgraph is manually streamed inside a parent node and hits an interrupt,
        the interrupt bubbles up as an error so the executor can handle it.
        """

    def __init__(
        self,
        *,
        chunk: _engine_common_pb2.ResponseChunk | None = ...,
        user_error: _errors_pb2.UserCodeExecutionError | None = ...,
        chat_message: _engine_common_pb2.ChatMessageEnvelope | None = ...,
        recursion_limit: _errors_pb2.GraphRecursionLimitError | None = ...,
        unsuppressed_interrupt_error: _engine_common_pb2.GraphInterrupt | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["chat_message", b"chat_message", "chunk", b"chunk", "message", b"message", "recursion_limit", b"recursion_limit", "unsuppressed_interrupt_error", b"unsuppressed_interrupt_error", "user_error", b"user_error"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["chat_message", b"chat_message", "chunk", b"chunk", "message", b"message", "recursion_limit", b"recursion_limit", "unsuppressed_interrupt_error", b"unsuppressed_interrupt_error", "user_error", b"user_error"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType_message: _TypeAlias = _typing.Literal["chunk", "user_error", "chat_message", "recursion_limit", "unsuppressed_interrupt_error"]  # noqa: Y015
    _WhichOneofArgType_message: _TypeAlias = _typing.Literal["message", b"message"]  # noqa: Y015
    def WhichOneof(self, oneof_group: _WhichOneofArgType_message) -> _WhichOneofReturnType_message | None: ...

Global___StreamOutputChunk: _TypeAlias = StreamOutputChunk  # noqa: Y015

@_typing.final
class UpdateStateRequest(_message.Message):
    """Update State"""

    DESCRIPTOR: _descriptor.Descriptor

    GRAPH_ID_FIELD_NUMBER: _builtins.int
    CONFIG_FIELD_NUMBER: _builtins.int
    UPDATE_FIELD_NUMBER: _builtins.int
    graph_id: _builtins.str
    @_builtins.property
    def config(self) -> _engine_common_pb2.EngineRunnableConfig: ...
    @_builtins.property
    def update(self) -> _engine_common_pb2.StateUpdate: ...
    def __init__(
        self,
        *,
        graph_id: _builtins.str = ...,
        config: _engine_common_pb2.EngineRunnableConfig | None = ...,
        update: _engine_common_pb2.StateUpdate | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["config", b"config", "update", b"update"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["config", b"config", "graph_id", b"graph_id", "update", b"update"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___UpdateStateRequest: _TypeAlias = UpdateStateRequest  # noqa: Y015

@_typing.final
class UpdateStateResponse(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    NEXT_CONFIG_FIELD_NUMBER: _builtins.int
    @_builtins.property
    def next_config(self) -> _engine_common_pb2.EngineRunnableConfig: ...
    def __init__(
        self,
        *,
        next_config: _engine_common_pb2.EngineRunnableConfig | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["next_config", b"next_config"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["next_config", b"next_config"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___UpdateStateResponse: _TypeAlias = UpdateStateResponse  # noqa: Y015

@_typing.final
class BulkUpdateStateRequest(_message.Message):
    """BulkUpdateState"""

    DESCRIPTOR: _descriptor.Descriptor

    GRAPH_ID_FIELD_NUMBER: _builtins.int
    CONFIG_FIELD_NUMBER: _builtins.int
    SUPERSTEPS_FIELD_NUMBER: _builtins.int
    graph_id: _builtins.str
    @_builtins.property
    def config(self) -> _engine_common_pb2.EngineRunnableConfig: ...
    @_builtins.property
    def supersteps(self) -> _containers.RepeatedCompositeFieldContainer[_engine_common_pb2.SuperstepUpdates]: ...
    def __init__(
        self,
        *,
        graph_id: _builtins.str = ...,
        config: _engine_common_pb2.EngineRunnableConfig | None = ...,
        supersteps: _abc.Iterable[_engine_common_pb2.SuperstepUpdates] | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["config", b"config"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["config", b"config", "graph_id", b"graph_id", "supersteps", b"supersteps"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___BulkUpdateStateRequest: _TypeAlias = BulkUpdateStateRequest  # noqa: Y015

@_typing.final
class BulkUpdateStateResponse(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    NEXT_CONFIG_FIELD_NUMBER: _builtins.int
    @_builtins.property
    def next_config(self) -> _engine_common_pb2.EngineRunnableConfig: ...
    def __init__(
        self,
        *,
        next_config: _engine_common_pb2.EngineRunnableConfig | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["next_config", b"next_config"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["next_config", b"next_config"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___BulkUpdateStateResponse: _TypeAlias = BulkUpdateStateResponse  # noqa: Y015

@_typing.final
class GetStateRequest(_message.Message):
    """get state"""

    DESCRIPTOR: _descriptor.Descriptor

    GRAPH_ID_FIELD_NUMBER: _builtins.int
    CONFIG_FIELD_NUMBER: _builtins.int
    SUBGRAPHS_FIELD_NUMBER: _builtins.int
    graph_id: _builtins.str
    subgraphs: _builtins.bool
    @_builtins.property
    def config(self) -> _engine_common_pb2.EngineRunnableConfig: ...
    def __init__(
        self,
        *,
        graph_id: _builtins.str = ...,
        config: _engine_common_pb2.EngineRunnableConfig | None = ...,
        subgraphs: _builtins.bool = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["config", b"config"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["config", b"config", "graph_id", b"graph_id", "subgraphs", b"subgraphs"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___GetStateRequest: _TypeAlias = GetStateRequest  # noqa: Y015

@_typing.final
class GetStateResponse(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    STATE_FIELD_NUMBER: _builtins.int
    @_builtins.property
    def state(self) -> _engine_common_pb2.StateSnapshot: ...
    def __init__(
        self,
        *,
        state: _engine_common_pb2.StateSnapshot | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["state", b"state"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["state", b"state"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___GetStateResponse: _TypeAlias = GetStateResponse  # noqa: Y015

@_typing.final
class GetStateHistoryRequest(_message.Message):
    """get state history"""

    DESCRIPTOR: _descriptor.Descriptor

    GRAPH_ID_FIELD_NUMBER: _builtins.int
    CONFIG_FIELD_NUMBER: _builtins.int
    FILTER_JSON_FIELD_NUMBER: _builtins.int
    BEFORE_FIELD_NUMBER: _builtins.int
    LIMIT_FIELD_NUMBER: _builtins.int
    graph_id: _builtins.str
    filter_json: _builtins.bytes
    limit: _builtins.int
    @_builtins.property
    def config(self) -> _engine_common_pb2.EngineRunnableConfig: ...
    @_builtins.property
    def before(self) -> _engine_common_pb2.EngineRunnableConfig: ...
    def __init__(
        self,
        *,
        graph_id: _builtins.str = ...,
        config: _engine_common_pb2.EngineRunnableConfig | None = ...,
        filter_json: _builtins.bytes = ...,
        before: _engine_common_pb2.EngineRunnableConfig | None = ...,
        limit: _builtins.int | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["_limit", b"_limit", "before", b"before", "config", b"config", "limit", b"limit"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["_limit", b"_limit", "before", b"before", "config", b"config", "filter_json", b"filter_json", "graph_id", b"graph_id", "limit", b"limit"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType__limit: _TypeAlias = _typing.Literal["limit"]  # noqa: Y015
    _WhichOneofArgType__limit: _TypeAlias = _typing.Literal["_limit", b"_limit"]  # noqa: Y015
    def WhichOneof(self, oneof_group: _WhichOneofArgType__limit) -> _WhichOneofReturnType__limit | None: ...

Global___GetStateHistoryRequest: _TypeAlias = GetStateHistoryRequest  # noqa: Y015

@_typing.final
class GetStateHistoryResponse(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    HISTORY_FIELD_NUMBER: _builtins.int
    @_builtins.property
    def history(self) -> _containers.RepeatedCompositeFieldContainer[_engine_common_pb2.StateSnapshot]: ...
    def __init__(
        self,
        *,
        history: _abc.Iterable[_engine_common_pb2.StateSnapshot] | None = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["history", b"history"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___GetStateHistoryResponse: _TypeAlias = GetStateHistoryResponse  # noqa: Y015

@_typing.final
class VectorValue(_message.Message):
    """Vector value for embedding support"""

    DESCRIPTOR: _descriptor.Descriptor

    VALUEPATH_FIELD_NUMBER: _builtins.int
    EMBEDDING_FIELD_NUMBER: _builtins.int
    valuePath: _builtins.str
    """path to the value in the document"""
    @_builtins.property
    def embedding(self) -> _containers.RepeatedScalarFieldContainer[_builtins.float]:
        """embedding vector"""

    def __init__(
        self,
        *,
        valuePath: _builtins.str = ...,
        embedding: _abc.Iterable[_builtins.float] | None = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["embedding", b"embedding", "valuePath", b"valuePath"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___VectorValue: _TypeAlias = VectorValue  # noqa: Y015

@_typing.final
class PutItemOperation(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    PREFIX_FIELD_NUMBER: _builtins.int
    KEY_FIELD_NUMBER: _builtins.int
    JSONVALUE_FIELD_NUMBER: _builtins.int
    TTLMINUTES_FIELD_NUMBER: _builtins.int
    VECTORS_FIELD_NUMBER: _builtins.int
    prefix: _builtins.str
    key: _builtins.str
    jsonValue: _builtins.str
    """the value must be a valid JSON string so that it can be inserted into the json field(JSONB of PostgreSQL)"""
    ttlMinutes: _builtins.int
    @_builtins.property
    def vectors(self) -> _containers.RepeatedCompositeFieldContainer[Global___VectorValue]:
        """array of vector values for embedding support"""

    def __init__(
        self,
        *,
        prefix: _builtins.str = ...,
        key: _builtins.str = ...,
        jsonValue: _builtins.str = ...,
        ttlMinutes: _builtins.int = ...,
        vectors: _abc.Iterable[Global___VectorValue] | None = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["jsonValue", b"jsonValue", "key", b"key", "prefix", b"prefix", "ttlMinutes", b"ttlMinutes", "vectors", b"vectors"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___PutItemOperation: _TypeAlias = PutItemOperation  # noqa: Y015

@_typing.final
class PutItemOperationResult(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

Global___PutItemOperationResult: _TypeAlias = PutItemOperationResult  # noqa: Y015

@_typing.final
class GetItemOperation(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    PREFIX_FIELD_NUMBER: _builtins.int
    KEY_FIELD_NUMBER: _builtins.int
    REFRESHTTL_FIELD_NUMBER: _builtins.int
    prefix: _builtins.str
    key: _builtins.str
    refreshTTL: _builtins.bool
    def __init__(
        self,
        *,
        prefix: _builtins.str = ...,
        key: _builtins.str = ...,
        refreshTTL: _builtins.bool = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["key", b"key", "prefix", b"prefix", "refreshTTL", b"refreshTTL"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___GetItemOperation: _TypeAlias = GetItemOperation  # noqa: Y015

@_typing.final
class GetItemOperationResult(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    JSONVALUE_FIELD_NUMBER: _builtins.int
    CREATEDAT_FIELD_NUMBER: _builtins.int
    UPDATEDAT_FIELD_NUMBER: _builtins.int
    jsonValue: _builtins.str
    @_builtins.property
    def createdAt(self) -> _timestamp_pb2.Timestamp: ...
    @_builtins.property
    def updatedAt(self) -> _timestamp_pb2.Timestamp: ...
    def __init__(
        self,
        *,
        jsonValue: _builtins.str = ...,
        createdAt: _timestamp_pb2.Timestamp | None = ...,
        updatedAt: _timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["createdAt", b"createdAt", "updatedAt", b"updatedAt"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["createdAt", b"createdAt", "jsonValue", b"jsonValue", "updatedAt", b"updatedAt"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___GetItemOperationResult: _TypeAlias = GetItemOperationResult  # noqa: Y015

@_typing.final
class SingleStoreOperation(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    OPERATIONTYPE_FIELD_NUMBER: _builtins.int
    PUT_FIELD_NUMBER: _builtins.int
    GET_FIELD_NUMBER: _builtins.int
    OperationType: _enum_store_operation_entry_type_pb2.StoreOperationEntryType.ValueType
    @_builtins.property
    def put(self) -> Global___PutItemOperation: ...
    @_builtins.property
    def get(self) -> Global___GetItemOperation: ...
    def __init__(
        self,
        *,
        OperationType: _enum_store_operation_entry_type_pb2.StoreOperationEntryType.ValueType = ...,
        put: Global___PutItemOperation | None = ...,
        get: Global___GetItemOperation | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["get", b"get", "put", b"put"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["OperationType", b"OperationType", "get", b"get", "put", b"put"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___SingleStoreOperation: _TypeAlias = SingleStoreOperation  # noqa: Y015

@_typing.final
class SingleStoreOperationResult(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    OPERATIONTYPE_FIELD_NUMBER: _builtins.int
    PUT_FIELD_NUMBER: _builtins.int
    GET_FIELD_NUMBER: _builtins.int
    OperationType: _enum_store_operation_entry_type_pb2.StoreOperationEntryType.ValueType
    @_builtins.property
    def put(self) -> Global___PutItemOperationResult: ...
    @_builtins.property
    def get(self) -> Global___GetItemOperationResult: ...
    def __init__(
        self,
        *,
        OperationType: _enum_store_operation_entry_type_pb2.StoreOperationEntryType.ValueType = ...,
        put: Global___PutItemOperationResult | None = ...,
        get: Global___GetItemOperationResult | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["get", b"get", "put", b"put"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["OperationType", b"OperationType", "get", b"get", "put", b"put"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___SingleStoreOperationResult: _TypeAlias = SingleStoreOperationResult  # noqa: Y015

@_typing.final
class BatchStoreOperationRequest(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    OPS_FIELD_NUMBER: _builtins.int
    @_builtins.property
    def ops(self) -> _containers.RepeatedCompositeFieldContainer[Global___SingleStoreOperation]: ...
    def __init__(
        self,
        *,
        ops: _abc.Iterable[Global___SingleStoreOperation] | None = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["ops", b"ops"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___BatchStoreOperationRequest: _TypeAlias = BatchStoreOperationRequest  # noqa: Y015

@_typing.final
class BatchStoreOperationResponse(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    OPS_FIELD_NUMBER: _builtins.int
    @_builtins.property
    def ops(self) -> _containers.RepeatedCompositeFieldContainer[Global___SingleStoreOperationResult]: ...
    def __init__(
        self,
        *,
        ops: _abc.Iterable[Global___SingleStoreOperationResult] | None = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["ops", b"ops"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___BatchStoreOperationResponse: _TypeAlias = BatchStoreOperationResponse  # noqa: Y015
