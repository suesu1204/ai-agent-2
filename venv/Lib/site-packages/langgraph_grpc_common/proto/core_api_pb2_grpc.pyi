"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
Protobuf definitions for low-level CRUD operations supported by LangSmith Deployment.
This is essentially an extended version of Agent Protocol (https://github.com/langchain-ai/agent-protocol).
"""

from collections import abc as _abc
from google.protobuf import empty_pb2 as _empty_pb2
from grpc import aio as _aio
import abc as _abc_1
from . import core_api_pb2 as _core_api_pb2
import grpc as _grpc
import sys
import typing as _typing

if sys.version_info >= (3, 11):
    from typing import Self as _Self
else:
    from typing_extensions import Self as _Self

_T = _typing.TypeVar("_T")

class _MaybeAsyncIterator(_abc.AsyncIterator[_T], _abc.Iterator[_T], metaclass=_abc_1.ABCMeta): ...

class _ServicerContext(_grpc.ServicerContext, _aio.ServicerContext):  # type: ignore[misc, type-arg]
    ...

GRPC_GENERATED_VERSION: str
GRPC_VERSION: str

class AssistantsStub:
    @_typing.overload
    def __new__(cls, channel: _grpc.Channel) -> _Self: ...
    @_typing.overload
    def __new__(cls, channel: _aio.Channel) -> AssistantsAsyncStub: ...
    Get: _grpc.UnaryUnaryMultiCallable[_core_api_pb2.GetAssistantRequest, _core_api_pb2.Assistant]
    Create: _grpc.UnaryUnaryMultiCallable[_core_api_pb2.CreateAssistantRequest, _core_api_pb2.Assistant]
    Patch: _grpc.UnaryUnaryMultiCallable[_core_api_pb2.PatchAssistantRequest, _core_api_pb2.Assistant]
    Delete: _grpc.UnaryUnaryMultiCallable[_core_api_pb2.DeleteAssistantRequest, _core_api_pb2.DeleteAssistantsResponse]
    Search: _grpc.UnaryUnaryMultiCallable[_core_api_pb2.SearchAssistantsRequest, _core_api_pb2.SearchAssistantsResponse]
    SetLatest: _grpc.UnaryUnaryMultiCallable[_core_api_pb2.SetLatestAssistantRequest, _core_api_pb2.Assistant]
    GetVersions: _grpc.UnaryUnaryMultiCallable[_core_api_pb2.GetAssistantVersionsRequest, _core_api_pb2.GetAssistantVersionsResponse]
    Count: _grpc.UnaryUnaryMultiCallable[_core_api_pb2.CountAssistantsRequest, _core_api_pb2.CountResponse]

@_typing.type_check_only
class AssistantsAsyncStub(AssistantsStub):
    def __init__(self, channel: _aio.Channel) -> None: ...
    Get: _aio.UnaryUnaryMultiCallable[_core_api_pb2.GetAssistantRequest, _core_api_pb2.Assistant]  # type: ignore[assignment]
    Create: _aio.UnaryUnaryMultiCallable[_core_api_pb2.CreateAssistantRequest, _core_api_pb2.Assistant]  # type: ignore[assignment]
    Patch: _aio.UnaryUnaryMultiCallable[_core_api_pb2.PatchAssistantRequest, _core_api_pb2.Assistant]  # type: ignore[assignment]
    Delete: _aio.UnaryUnaryMultiCallable[_core_api_pb2.DeleteAssistantRequest, _core_api_pb2.DeleteAssistantsResponse]  # type: ignore[assignment]
    Search: _aio.UnaryUnaryMultiCallable[_core_api_pb2.SearchAssistantsRequest, _core_api_pb2.SearchAssistantsResponse]  # type: ignore[assignment]
    SetLatest: _aio.UnaryUnaryMultiCallable[_core_api_pb2.SetLatestAssistantRequest, _core_api_pb2.Assistant]  # type: ignore[assignment]
    GetVersions: _aio.UnaryUnaryMultiCallable[_core_api_pb2.GetAssistantVersionsRequest, _core_api_pb2.GetAssistantVersionsResponse]  # type: ignore[assignment]
    Count: _aio.UnaryUnaryMultiCallable[_core_api_pb2.CountAssistantsRequest, _core_api_pb2.CountResponse]  # type: ignore[assignment]

class AssistantsServicer(metaclass=_abc_1.ABCMeta):
    @_abc_1.abstractmethod
    def Get(
        self,
        request: _core_api_pb2.GetAssistantRequest,
        context: _ServicerContext,
    ) -> _typing.Union[_core_api_pb2.Assistant, _abc.Awaitable[_core_api_pb2.Assistant]]: ...

    @_abc_1.abstractmethod
    def Create(
        self,
        request: _core_api_pb2.CreateAssistantRequest,
        context: _ServicerContext,
    ) -> _typing.Union[_core_api_pb2.Assistant, _abc.Awaitable[_core_api_pb2.Assistant]]: ...

    @_abc_1.abstractmethod
    def Patch(
        self,
        request: _core_api_pb2.PatchAssistantRequest,
        context: _ServicerContext,
    ) -> _typing.Union[_core_api_pb2.Assistant, _abc.Awaitable[_core_api_pb2.Assistant]]: ...

    @_abc_1.abstractmethod
    def Delete(
        self,
        request: _core_api_pb2.DeleteAssistantRequest,
        context: _ServicerContext,
    ) -> _typing.Union[_core_api_pb2.DeleteAssistantsResponse, _abc.Awaitable[_core_api_pb2.DeleteAssistantsResponse]]: ...

    @_abc_1.abstractmethod
    def Search(
        self,
        request: _core_api_pb2.SearchAssistantsRequest,
        context: _ServicerContext,
    ) -> _typing.Union[_core_api_pb2.SearchAssistantsResponse, _abc.Awaitable[_core_api_pb2.SearchAssistantsResponse]]: ...

    @_abc_1.abstractmethod
    def SetLatest(
        self,
        request: _core_api_pb2.SetLatestAssistantRequest,
        context: _ServicerContext,
    ) -> _typing.Union[_core_api_pb2.Assistant, _abc.Awaitable[_core_api_pb2.Assistant]]: ...

    @_abc_1.abstractmethod
    def GetVersions(
        self,
        request: _core_api_pb2.GetAssistantVersionsRequest,
        context: _ServicerContext,
    ) -> _typing.Union[_core_api_pb2.GetAssistantVersionsResponse, _abc.Awaitable[_core_api_pb2.GetAssistantVersionsResponse]]: ...

    @_abc_1.abstractmethod
    def Count(
        self,
        request: _core_api_pb2.CountAssistantsRequest,
        context: _ServicerContext,
    ) -> _typing.Union[_core_api_pb2.CountResponse, _abc.Awaitable[_core_api_pb2.CountResponse]]: ...

def add_AssistantsServicer_to_server(servicer: AssistantsServicer, server: _typing.Union[_grpc.Server, _aio.Server]) -> None: ...

class AdminStub:
    """Global database admin operations."""

    @_typing.overload
    def __new__(cls, channel: _grpc.Channel) -> _Self: ...
    @_typing.overload
    def __new__(cls, channel: _aio.Channel) -> AdminAsyncStub: ...
    Truncate: _grpc.UnaryUnaryMultiCallable[_core_api_pb2.TruncateRequest, _empty_pb2.Empty]
    """Truncate all RDBMS data (supported in dev only!)"""

@_typing.type_check_only
class AdminAsyncStub(AdminStub):
    """Global database admin operations."""

    def __init__(self, channel: _aio.Channel) -> None: ...
    Truncate: _aio.UnaryUnaryMultiCallable[_core_api_pb2.TruncateRequest, _empty_pb2.Empty]  # type: ignore[assignment]
    """Truncate all RDBMS data (supported in dev only!)"""

class AdminServicer(metaclass=_abc_1.ABCMeta):
    """Global database admin operations."""

    @_abc_1.abstractmethod
    def Truncate(
        self,
        request: _core_api_pb2.TruncateRequest,
        context: _ServicerContext,
    ) -> _typing.Union[_empty_pb2.Empty, _abc.Awaitable[_empty_pb2.Empty]]:
        """Truncate all RDBMS data (supported in dev only!)"""

def add_AdminServicer_to_server(servicer: AdminServicer, server: _typing.Union[_grpc.Server, _aio.Server]) -> None: ...

class ThreadsStub:
    @_typing.overload
    def __new__(cls, channel: _grpc.Channel) -> _Self: ...
    @_typing.overload
    def __new__(cls, channel: _aio.Channel) -> ThreadsAsyncStub: ...
    Create: _grpc.UnaryUnaryMultiCallable[_core_api_pb2.CreateThreadRequest, _core_api_pb2.Thread]
    Get: _grpc.UnaryUnaryMultiCallable[_core_api_pb2.GetThreadRequest, _core_api_pb2.Thread]
    Patch: _grpc.UnaryUnaryMultiCallable[_core_api_pb2.PatchThreadRequest, _core_api_pb2.Thread]
    Delete: _grpc.UnaryUnaryMultiCallable[_core_api_pb2.DeleteThreadRequest, _core_api_pb2.UUID]
    Search: _grpc.UnaryUnaryMultiCallable[_core_api_pb2.SearchThreadsRequest, _core_api_pb2.SearchThreadsResponse]
    Count: _grpc.UnaryUnaryMultiCallable[_core_api_pb2.CountThreadsRequest, _core_api_pb2.CountResponse]
    Copy: _grpc.UnaryUnaryMultiCallable[_core_api_pb2.CopyThreadRequest, _core_api_pb2.Thread]
    SetStatus: _grpc.UnaryUnaryMultiCallable[_core_api_pb2.SetThreadStatusRequest, _empty_pb2.Empty]
    Stream: _grpc.UnaryStreamMultiCallable[_core_api_pb2.StreamThreadRequest, _core_api_pb2.StreamEvent]
    """Stream run events for all runs associated with the thread."""
    SetJointStatus: _grpc.UnaryUnaryMultiCallable[_core_api_pb2.SetThreadJointStatusRequest, _empty_pb2.Empty]
    """Set the status of a thread and run atomically."""
    GetGraphID: _grpc.UnaryUnaryMultiCallable[_core_api_pb2.GetGraphIDRequest, _core_api_pb2.GetGraphIDResponse]
    """Get graph ID for the latest run in a thread (internal method, no auth)."""

@_typing.type_check_only
class ThreadsAsyncStub(ThreadsStub):
    def __init__(self, channel: _aio.Channel) -> None: ...
    Create: _aio.UnaryUnaryMultiCallable[_core_api_pb2.CreateThreadRequest, _core_api_pb2.Thread]  # type: ignore[assignment]
    Get: _aio.UnaryUnaryMultiCallable[_core_api_pb2.GetThreadRequest, _core_api_pb2.Thread]  # type: ignore[assignment]
    Patch: _aio.UnaryUnaryMultiCallable[_core_api_pb2.PatchThreadRequest, _core_api_pb2.Thread]  # type: ignore[assignment]
    Delete: _aio.UnaryUnaryMultiCallable[_core_api_pb2.DeleteThreadRequest, _core_api_pb2.UUID]  # type: ignore[assignment]
    Search: _aio.UnaryUnaryMultiCallable[_core_api_pb2.SearchThreadsRequest, _core_api_pb2.SearchThreadsResponse]  # type: ignore[assignment]
    Count: _aio.UnaryUnaryMultiCallable[_core_api_pb2.CountThreadsRequest, _core_api_pb2.CountResponse]  # type: ignore[assignment]
    Copy: _aio.UnaryUnaryMultiCallable[_core_api_pb2.CopyThreadRequest, _core_api_pb2.Thread]  # type: ignore[assignment]
    SetStatus: _aio.UnaryUnaryMultiCallable[_core_api_pb2.SetThreadStatusRequest, _empty_pb2.Empty]  # type: ignore[assignment]
    Stream: _aio.UnaryStreamMultiCallable[_core_api_pb2.StreamThreadRequest, _core_api_pb2.StreamEvent]  # type: ignore[assignment]
    """Stream run events for all runs associated with the thread."""
    SetJointStatus: _aio.UnaryUnaryMultiCallable[_core_api_pb2.SetThreadJointStatusRequest, _empty_pb2.Empty]  # type: ignore[assignment]
    """Set the status of a thread and run atomically."""
    GetGraphID: _aio.UnaryUnaryMultiCallable[_core_api_pb2.GetGraphIDRequest, _core_api_pb2.GetGraphIDResponse]  # type: ignore[assignment]
    """Get graph ID for the latest run in a thread (internal method, no auth)."""

class ThreadsServicer(metaclass=_abc_1.ABCMeta):
    @_abc_1.abstractmethod
    def Create(
        self,
        request: _core_api_pb2.CreateThreadRequest,
        context: _ServicerContext,
    ) -> _typing.Union[_core_api_pb2.Thread, _abc.Awaitable[_core_api_pb2.Thread]]: ...

    @_abc_1.abstractmethod
    def Get(
        self,
        request: _core_api_pb2.GetThreadRequest,
        context: _ServicerContext,
    ) -> _typing.Union[_core_api_pb2.Thread, _abc.Awaitable[_core_api_pb2.Thread]]: ...

    @_abc_1.abstractmethod
    def Patch(
        self,
        request: _core_api_pb2.PatchThreadRequest,
        context: _ServicerContext,
    ) -> _typing.Union[_core_api_pb2.Thread, _abc.Awaitable[_core_api_pb2.Thread]]: ...

    @_abc_1.abstractmethod
    def Delete(
        self,
        request: _core_api_pb2.DeleteThreadRequest,
        context: _ServicerContext,
    ) -> _typing.Union[_core_api_pb2.UUID, _abc.Awaitable[_core_api_pb2.UUID]]: ...

    @_abc_1.abstractmethod
    def Search(
        self,
        request: _core_api_pb2.SearchThreadsRequest,
        context: _ServicerContext,
    ) -> _typing.Union[_core_api_pb2.SearchThreadsResponse, _abc.Awaitable[_core_api_pb2.SearchThreadsResponse]]: ...

    @_abc_1.abstractmethod
    def Count(
        self,
        request: _core_api_pb2.CountThreadsRequest,
        context: _ServicerContext,
    ) -> _typing.Union[_core_api_pb2.CountResponse, _abc.Awaitable[_core_api_pb2.CountResponse]]: ...

    @_abc_1.abstractmethod
    def Copy(
        self,
        request: _core_api_pb2.CopyThreadRequest,
        context: _ServicerContext,
    ) -> _typing.Union[_core_api_pb2.Thread, _abc.Awaitable[_core_api_pb2.Thread]]: ...

    @_abc_1.abstractmethod
    def SetStatus(
        self,
        request: _core_api_pb2.SetThreadStatusRequest,
        context: _ServicerContext,
    ) -> _typing.Union[_empty_pb2.Empty, _abc.Awaitable[_empty_pb2.Empty]]: ...

    @_abc_1.abstractmethod
    def Stream(
        self,
        request: _core_api_pb2.StreamThreadRequest,
        context: _ServicerContext,
    ) -> _typing.Union[_abc.Iterator[_core_api_pb2.StreamEvent], _abc.AsyncIterator[_core_api_pb2.StreamEvent]]:
        """Stream run events for all runs associated with the thread."""

    @_abc_1.abstractmethod
    def SetJointStatus(
        self,
        request: _core_api_pb2.SetThreadJointStatusRequest,
        context: _ServicerContext,
    ) -> _typing.Union[_empty_pb2.Empty, _abc.Awaitable[_empty_pb2.Empty]]:
        """Set the status of a thread and run atomically."""

    @_abc_1.abstractmethod
    def GetGraphID(
        self,
        request: _core_api_pb2.GetGraphIDRequest,
        context: _ServicerContext,
    ) -> _typing.Union[_core_api_pb2.GetGraphIDResponse, _abc.Awaitable[_core_api_pb2.GetGraphIDResponse]]:
        """Get graph ID for the latest run in a thread (internal method, no auth)."""

def add_ThreadsServicer_to_server(servicer: ThreadsServicer, server: _typing.Union[_grpc.Server, _aio.Server]) -> None: ...

class RunsStub:
    @_typing.overload
    def __new__(cls, channel: _grpc.Channel) -> _Self: ...
    @_typing.overload
    def __new__(cls, channel: _aio.Channel) -> RunsAsyncStub: ...
    Create: _grpc.UnaryUnaryMultiCallable[_core_api_pb2.CreateRunRequest, _core_api_pb2.CreateRunResponse]
    Get: _grpc.UnaryUnaryMultiCallable[_core_api_pb2.GetRunRequest, _core_api_pb2.Run]
    Delete: _grpc.UnaryUnaryMultiCallable[_core_api_pb2.DeleteRunRequest, _core_api_pb2.UUID]
    Search: _grpc.UnaryUnaryMultiCallable[_core_api_pb2.SearchRunsRequest, _core_api_pb2.SearchRunsResponse]
    Cancel: _grpc.UnaryUnaryMultiCallable[_core_api_pb2.CancelRunRequest, _empty_pb2.Empty]
    SetStatus: _grpc.UnaryUnaryMultiCallable[_core_api_pb2.SetRunStatusRequest, _empty_pb2.Empty]
    Stream: _grpc.StreamStreamMultiCallable[_core_api_pb2.StreamRunClientMessage, _core_api_pb2.StreamEvent]
    """Bidirectional stream for run events.
    Client opens stream, then sends JoinRunRequest to start receiving events.
    Server validates auth on join and starts streaming events.
    If client disconnects and cancel_on_disconnect was set, the run is cancelled.
    """
    Publish: _grpc.UnaryUnaryMultiCallable[_core_api_pb2.PublishStreamEventRequest, _empty_pb2.Empty]
    """Publish a stream event for a run"""
    Enter: _grpc.UnaryStreamMultiCallable[_core_api_pb2.EnterRunRequest, _core_api_pb2.ControlEvent]
    """Enter a run - starts heartbeat and streams control signals (internal worker method)
    Returns a stream of interrupt/rollback signals for the specified run
    """
    MarkDone: _grpc.UnaryUnaryMultiCallable[_core_api_pb2.MarkRunDoneRequest, _empty_pb2.Empty]
    """Mark a run as done (internal worker method)"""
    Stats: _grpc.UnaryUnaryMultiCallable[_empty_pb2.Empty, _core_api_pb2.RunStats]
    """Get run statistics (internal method, no auth)"""
    Count: _grpc.UnaryUnaryMultiCallable[_core_api_pb2.CountRunsRequest, _core_api_pb2.CountResponse]
    """Count runs matching criteria (internal method, no auth)"""
    Next: _grpc.UnaryUnaryMultiCallable[_core_api_pb2.NextRunRequest, _core_api_pb2.NextRunResponse]
    """Get next run from queue (internal worker method, no auth)
    TODO: come back
    """
    Sweep: _grpc.UnaryUnaryMultiCallable[_empty_pb2.Empty, _core_api_pb2.SweepRunsResponse]
    """Sweep abandoned runs (internal method, no auth)"""

@_typing.type_check_only
class RunsAsyncStub(RunsStub):
    def __init__(self, channel: _aio.Channel) -> None: ...
    Create: _aio.UnaryUnaryMultiCallable[_core_api_pb2.CreateRunRequest, _core_api_pb2.CreateRunResponse]  # type: ignore[assignment]
    Get: _aio.UnaryUnaryMultiCallable[_core_api_pb2.GetRunRequest, _core_api_pb2.Run]  # type: ignore[assignment]
    Delete: _aio.UnaryUnaryMultiCallable[_core_api_pb2.DeleteRunRequest, _core_api_pb2.UUID]  # type: ignore[assignment]
    Search: _aio.UnaryUnaryMultiCallable[_core_api_pb2.SearchRunsRequest, _core_api_pb2.SearchRunsResponse]  # type: ignore[assignment]
    Cancel: _aio.UnaryUnaryMultiCallable[_core_api_pb2.CancelRunRequest, _empty_pb2.Empty]  # type: ignore[assignment]
    SetStatus: _aio.UnaryUnaryMultiCallable[_core_api_pb2.SetRunStatusRequest, _empty_pb2.Empty]  # type: ignore[assignment]
    Stream: _aio.StreamStreamMultiCallable[_core_api_pb2.StreamRunClientMessage, _core_api_pb2.StreamEvent]  # type: ignore[assignment]
    """Bidirectional stream for run events.
    Client opens stream, then sends JoinRunRequest to start receiving events.
    Server validates auth on join and starts streaming events.
    If client disconnects and cancel_on_disconnect was set, the run is cancelled.
    """
    Publish: _aio.UnaryUnaryMultiCallable[_core_api_pb2.PublishStreamEventRequest, _empty_pb2.Empty]  # type: ignore[assignment]
    """Publish a stream event for a run"""
    Enter: _aio.UnaryStreamMultiCallable[_core_api_pb2.EnterRunRequest, _core_api_pb2.ControlEvent]  # type: ignore[assignment]
    """Enter a run - starts heartbeat and streams control signals (internal worker method)
    Returns a stream of interrupt/rollback signals for the specified run
    """
    MarkDone: _aio.UnaryUnaryMultiCallable[_core_api_pb2.MarkRunDoneRequest, _empty_pb2.Empty]  # type: ignore[assignment]
    """Mark a run as done (internal worker method)"""
    Stats: _aio.UnaryUnaryMultiCallable[_empty_pb2.Empty, _core_api_pb2.RunStats]  # type: ignore[assignment]
    """Get run statistics (internal method, no auth)"""
    Count: _aio.UnaryUnaryMultiCallable[_core_api_pb2.CountRunsRequest, _core_api_pb2.CountResponse]  # type: ignore[assignment]
    """Count runs matching criteria (internal method, no auth)"""
    Next: _aio.UnaryUnaryMultiCallable[_core_api_pb2.NextRunRequest, _core_api_pb2.NextRunResponse]  # type: ignore[assignment]
    """Get next run from queue (internal worker method, no auth)
    TODO: come back
    """
    Sweep: _aio.UnaryUnaryMultiCallable[_empty_pb2.Empty, _core_api_pb2.SweepRunsResponse]  # type: ignore[assignment]
    """Sweep abandoned runs (internal method, no auth)"""

class RunsServicer(metaclass=_abc_1.ABCMeta):
    @_abc_1.abstractmethod
    def Create(
        self,
        request: _core_api_pb2.CreateRunRequest,
        context: _ServicerContext,
    ) -> _typing.Union[_core_api_pb2.CreateRunResponse, _abc.Awaitable[_core_api_pb2.CreateRunResponse]]: ...

    @_abc_1.abstractmethod
    def Get(
        self,
        request: _core_api_pb2.GetRunRequest,
        context: _ServicerContext,
    ) -> _typing.Union[_core_api_pb2.Run, _abc.Awaitable[_core_api_pb2.Run]]: ...

    @_abc_1.abstractmethod
    def Delete(
        self,
        request: _core_api_pb2.DeleteRunRequest,
        context: _ServicerContext,
    ) -> _typing.Union[_core_api_pb2.UUID, _abc.Awaitable[_core_api_pb2.UUID]]: ...

    @_abc_1.abstractmethod
    def Search(
        self,
        request: _core_api_pb2.SearchRunsRequest,
        context: _ServicerContext,
    ) -> _typing.Union[_core_api_pb2.SearchRunsResponse, _abc.Awaitable[_core_api_pb2.SearchRunsResponse]]: ...

    @_abc_1.abstractmethod
    def Cancel(
        self,
        request: _core_api_pb2.CancelRunRequest,
        context: _ServicerContext,
    ) -> _typing.Union[_empty_pb2.Empty, _abc.Awaitable[_empty_pb2.Empty]]: ...

    @_abc_1.abstractmethod
    def SetStatus(
        self,
        request: _core_api_pb2.SetRunStatusRequest,
        context: _ServicerContext,
    ) -> _typing.Union[_empty_pb2.Empty, _abc.Awaitable[_empty_pb2.Empty]]: ...

    @_abc_1.abstractmethod
    def Stream(
        self,
        request_iterator: _MaybeAsyncIterator[_core_api_pb2.StreamRunClientMessage],
        context: _ServicerContext,
    ) -> _typing.Union[_abc.Iterator[_core_api_pb2.StreamEvent], _abc.AsyncIterator[_core_api_pb2.StreamEvent]]:
        """Bidirectional stream for run events.
        Client opens stream, then sends JoinRunRequest to start receiving events.
        Server validates auth on join and starts streaming events.
        If client disconnects and cancel_on_disconnect was set, the run is cancelled.
        """

    @_abc_1.abstractmethod
    def Publish(
        self,
        request: _core_api_pb2.PublishStreamEventRequest,
        context: _ServicerContext,
    ) -> _typing.Union[_empty_pb2.Empty, _abc.Awaitable[_empty_pb2.Empty]]:
        """Publish a stream event for a run"""

    @_abc_1.abstractmethod
    def Enter(
        self,
        request: _core_api_pb2.EnterRunRequest,
        context: _ServicerContext,
    ) -> _typing.Union[_abc.Iterator[_core_api_pb2.ControlEvent], _abc.AsyncIterator[_core_api_pb2.ControlEvent]]:
        """Enter a run - starts heartbeat and streams control signals (internal worker method)
        Returns a stream of interrupt/rollback signals for the specified run
        """

    @_abc_1.abstractmethod
    def MarkDone(
        self,
        request: _core_api_pb2.MarkRunDoneRequest,
        context: _ServicerContext,
    ) -> _typing.Union[_empty_pb2.Empty, _abc.Awaitable[_empty_pb2.Empty]]:
        """Mark a run as done (internal worker method)"""

    @_abc_1.abstractmethod
    def Stats(
        self,
        request: _empty_pb2.Empty,
        context: _ServicerContext,
    ) -> _typing.Union[_core_api_pb2.RunStats, _abc.Awaitable[_core_api_pb2.RunStats]]:
        """Get run statistics (internal method, no auth)"""

    @_abc_1.abstractmethod
    def Count(
        self,
        request: _core_api_pb2.CountRunsRequest,
        context: _ServicerContext,
    ) -> _typing.Union[_core_api_pb2.CountResponse, _abc.Awaitable[_core_api_pb2.CountResponse]]:
        """Count runs matching criteria (internal method, no auth)"""

    @_abc_1.abstractmethod
    def Next(
        self,
        request: _core_api_pb2.NextRunRequest,
        context: _ServicerContext,
    ) -> _typing.Union[_core_api_pb2.NextRunResponse, _abc.Awaitable[_core_api_pb2.NextRunResponse]]:
        """Get next run from queue (internal worker method, no auth)
        TODO: come back
        """

    @_abc_1.abstractmethod
    def Sweep(
        self,
        request: _empty_pb2.Empty,
        context: _ServicerContext,
    ) -> _typing.Union[_core_api_pb2.SweepRunsResponse, _abc.Awaitable[_core_api_pb2.SweepRunsResponse]]:
        """Sweep abandoned runs (internal method, no auth)"""

def add_RunsServicer_to_server(servicer: RunsServicer, server: _typing.Union[_grpc.Server, _aio.Server]) -> None: ...
