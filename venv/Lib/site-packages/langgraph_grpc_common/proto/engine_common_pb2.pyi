"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
engineCommon is the protos shared between engineApi and executorApi
Some of these (EngineRunnableConfig, Checkpoint, ...) are by coreApi and checkpointer as well.
"""

from collections import abc as _abc
from google.protobuf import descriptor as _descriptor
from google.protobuf import empty_pb2 as _empty_pb2
from google.protobuf import message as _message
from google.protobuf import wrappers_pb2 as _wrappers_pb2
from google.protobuf.internal import containers as _containers
from google.protobuf.internal import enum_type_wrapper as _enum_type_wrapper
import builtins as _builtins
from . import enum_durability_pb2 as _enum_durability_pb2
from . import enum_stream_mode_pb2 as _enum_stream_mode_pb2
from . import errors_pb2 as _errors_pb2
import sys
import typing as _typing

if sys.version_info >= (3, 10):
    from typing import TypeAlias as _TypeAlias
else:
    from typing_extensions import TypeAlias as _TypeAlias

DESCRIPTOR: _descriptor.FileDescriptor

@_typing.final
class ChannelValue(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    SERIALIZED_VALUE_FIELD_NUMBER: _builtins.int
    SENDS_FIELD_NUMBER: _builtins.int
    MISSING_FIELD_NUMBER: _builtins.int
    @_builtins.property
    def serialized_value(self) -> Global___SerializedValue: ...
    @_builtins.property
    def sends(self) -> Global___Sends: ...
    @_builtins.property
    def missing(self) -> _empty_pb2.Empty: ...
    def __init__(
        self,
        *,
        serialized_value: Global___SerializedValue | None = ...,
        sends: Global___Sends | None = ...,
        missing: _empty_pb2.Empty | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["missing", b"missing", "sends", b"sends", "serialized_value", b"serialized_value", "val", b"val"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["missing", b"missing", "sends", b"sends", "serialized_value", b"serialized_value", "val", b"val"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType_val: _TypeAlias = _typing.Literal["serialized_value", "sends", "missing"]  # noqa: Y015
    _WhichOneofArgType_val: _TypeAlias = _typing.Literal["val", b"val"]  # noqa: Y015
    def WhichOneof(self, oneof_group: _WhichOneofArgType_val) -> _WhichOneofReturnType_val | None: ...

Global___ChannelValue: _TypeAlias = ChannelValue  # noqa: Y015

@_typing.final
class SerializedValue(_message.Message):
    """SerializedValue"""

    DESCRIPTOR: _descriptor.Descriptor

    ENCODING_FIELD_NUMBER: _builtins.int
    VALUE_FIELD_NUMBER: _builtins.int
    encoding: _builtins.str
    """the encoding/serialization type of the value, for user code to deserialize"""
    value: _builtins.bytes
    """the serialized value"""
    def __init__(
        self,
        *,
        encoding: _builtins.str = ...,
        value: _builtins.bytes = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["encoding", b"encoding", "value", b"value"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___SerializedValue: _TypeAlias = SerializedValue  # noqa: Y015

@_typing.final
class ResponseChunk(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    NAMESPACES_FIELD_NUMBER: _builtins.int
    MODE_FIELD_NUMBER: _builtins.int
    PAYLOAD_FIELD_NUMBER: _builtins.int
    mode: _builtins.str
    @_builtins.property
    def namespaces(self) -> _containers.RepeatedScalarFieldContainer[_builtins.str]: ...
    @_builtins.property
    def payload(self) -> Global___SerializedValue: ...
    def __init__(
        self,
        *,
        namespaces: _abc.Iterable[_builtins.str] | None = ...,
        mode: _builtins.str = ...,
        payload: Global___SerializedValue | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["payload", b"payload"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["mode", b"mode", "namespaces", b"namespaces", "payload", b"payload"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___ResponseChunk: _TypeAlias = ResponseChunk  # noqa: Y015

@_typing.final
class ResponseChunkList(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    RESPONSES_FIELD_NUMBER: _builtins.int
    @_builtins.property
    def responses(self) -> _containers.RepeatedCompositeFieldContainer[Global___ResponseChunk]: ...
    def __init__(
        self,
        *,
        responses: _abc.Iterable[Global___ResponseChunk] | None = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["responses", b"responses"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___ResponseChunkList: _TypeAlias = ResponseChunkList  # noqa: Y015

@_typing.final
class MessageIds(_message.Message):
    """MessageIds"""

    DESCRIPTOR: _descriptor.Descriptor

    MESSAGE_IDS_FIELD_NUMBER: _builtins.int
    @_builtins.property
    def message_ids(self) -> _containers.RepeatedScalarFieldContainer[_builtins.str]: ...
    def __init__(
        self,
        *,
        message_ids: _abc.Iterable[_builtins.str] | None = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["message_ids", b"message_ids"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___MessageIds: _TypeAlias = MessageIds  # noqa: Y015

@_typing.final
class Channels(_message.Message):
    """Channels"""

    DESCRIPTOR: _descriptor.Descriptor

    @_typing.final
    class ChannelsEntry(_message.Message):
        DESCRIPTOR: _descriptor.Descriptor

        KEY_FIELD_NUMBER: _builtins.int
        VALUE_FIELD_NUMBER: _builtins.int
        key: _builtins.str
        @_builtins.property
        def value(self) -> Global___Channel: ...
        def __init__(
            self,
            *,
            key: _builtins.str = ...,
            value: Global___Channel | None = ...,
        ) -> None: ...
        _HasFieldArgType: _TypeAlias = _typing.Literal["value", b"value"]  # noqa: Y015
        def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal["key", b"key", "value", b"value"]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

    CHANNELS_FIELD_NUMBER: _builtins.int
    @_builtins.property
    def channels(self) -> _containers.MessageMap[_builtins.str, Global___Channel]: ...
    def __init__(
        self,
        *,
        channels: _abc.Mapping[_builtins.str, Global___Channel] | None = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["channels", b"channels"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___Channels: _TypeAlias = Channels  # noqa: Y015

@_typing.final
class Channel(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    GET_RESULT_FIELD_NUMBER: _builtins.int
    IS_AVAILABLE_RESULT_FIELD_NUMBER: _builtins.int
    CHECKPOINT_RESULT_FIELD_NUMBER: _builtins.int
    is_available_result: _builtins.bool
    @_builtins.property
    def get_result(self) -> Global___ChannelValue: ...
    @_builtins.property
    def checkpoint_result(self) -> Global___ChannelValue: ...
    def __init__(
        self,
        *,
        get_result: Global___ChannelValue | None = ...,
        is_available_result: _builtins.bool = ...,
        checkpoint_result: Global___ChannelValue | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["checkpoint_result", b"checkpoint_result", "get_result", b"get_result"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["checkpoint_result", b"checkpoint_result", "get_result", b"get_result", "is_available_result", b"is_available_result"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___Channel: _TypeAlias = Channel  # noqa: Y015

@_typing.final
class Sends(_message.Message):
    """Send"""

    DESCRIPTOR: _descriptor.Descriptor

    SENDS_FIELD_NUMBER: _builtins.int
    @_builtins.property
    def sends(self) -> _containers.RepeatedCompositeFieldContainer[Global___Send]: ...
    def __init__(
        self,
        *,
        sends: _abc.Iterable[Global___Send] | None = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["sends", b"sends"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___Sends: _TypeAlias = Sends  # noqa: Y015

@_typing.final
class Send(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    NODE_FIELD_NUMBER: _builtins.int
    ARG_FIELD_NUMBER: _builtins.int
    node: _builtins.str
    @_builtins.property
    def arg(self) -> Global___SerializedValue: ...
    def __init__(
        self,
        *,
        node: _builtins.str = ...,
        arg: Global___SerializedValue | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["arg", b"arg"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["arg", b"arg", "node", b"node"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___Send: _TypeAlias = Send  # noqa: Y015

@_typing.final
class Command(_message.Message):
    """Command is returned from a node to simultaneously update and route
       values to other nodes.
    It can also be constructed from a RunCommand, which is created by
    the user to invoke a graph.
    """

    DESCRIPTOR: _descriptor.Descriptor

    @_typing.final
    class UpdateEntry(_message.Message):
        DESCRIPTOR: _descriptor.Descriptor

        KEY_FIELD_NUMBER: _builtins.int
        VALUE_FIELD_NUMBER: _builtins.int
        key: _builtins.str
        @_builtins.property
        def value(self) -> Global___SerializedValue: ...
        def __init__(
            self,
            *,
            key: _builtins.str = ...,
            value: Global___SerializedValue | None = ...,
        ) -> None: ...
        _HasFieldArgType: _TypeAlias = _typing.Literal["value", b"value"]  # noqa: Y015
        def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal["key", b"key", "value", b"value"]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

    GRAPH_FIELD_NUMBER: _builtins.int
    UPDATE_FIELD_NUMBER: _builtins.int
    RESUME_FIELD_NUMBER: _builtins.int
    GOTOS_FIELD_NUMBER: _builtins.int
    graph: _builtins.str
    @_builtins.property
    def update(self) -> _containers.MessageMap[_builtins.str, Global___SerializedValue]: ...
    @_builtins.property
    def resume(self) -> Global___Resume: ...
    @_builtins.property
    def gotos(self) -> _containers.RepeatedCompositeFieldContainer[Global___Goto]: ...
    def __init__(
        self,
        *,
        graph: _builtins.str | None = ...,
        update: _abc.Mapping[_builtins.str, Global___SerializedValue] | None = ...,
        resume: Global___Resume | None = ...,
        gotos: _abc.Iterable[Global___Goto] | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["_graph", b"_graph", "graph", b"graph", "resume", b"resume"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["_graph", b"_graph", "gotos", b"gotos", "graph", b"graph", "resume", b"resume", "update", b"update"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType__graph: _TypeAlias = _typing.Literal["graph"]  # noqa: Y015
    _WhichOneofArgType__graph: _TypeAlias = _typing.Literal["_graph", b"_graph"]  # noqa: Y015
    def WhichOneof(self, oneof_group: _WhichOneofArgType__graph) -> _WhichOneofReturnType__graph | None: ...

Global___Command: _TypeAlias = Command  # noqa: Y015

@_typing.final
class Resume(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    VALUE_FIELD_NUMBER: _builtins.int
    VALUES_FIELD_NUMBER: _builtins.int
    @_builtins.property
    def value(self) -> Global___SerializedValue: ...
    @_builtins.property
    def values(self) -> Global___InterruptValues: ...
    def __init__(
        self,
        *,
        value: Global___SerializedValue | None = ...,
        values: Global___InterruptValues | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["message", b"message", "value", b"value", "values", b"values"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["message", b"message", "value", b"value", "values", b"values"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType_message: _TypeAlias = _typing.Literal["value", "values"]  # noqa: Y015
    _WhichOneofArgType_message: _TypeAlias = _typing.Literal["message", b"message"]  # noqa: Y015
    def WhichOneof(self, oneof_group: _WhichOneofArgType_message) -> _WhichOneofReturnType_message | None: ...

Global___Resume: _TypeAlias = Resume  # noqa: Y015

@_typing.final
class InterruptValues(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    @_typing.final
    class ValuesEntry(_message.Message):
        DESCRIPTOR: _descriptor.Descriptor

        KEY_FIELD_NUMBER: _builtins.int
        VALUE_FIELD_NUMBER: _builtins.int
        key: _builtins.str
        @_builtins.property
        def value(self) -> Global___SerializedValue: ...
        def __init__(
            self,
            *,
            key: _builtins.str = ...,
            value: Global___SerializedValue | None = ...,
        ) -> None: ...
        _HasFieldArgType: _TypeAlias = _typing.Literal["value", b"value"]  # noqa: Y015
        def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal["key", b"key", "value", b"value"]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

    VALUES_FIELD_NUMBER: _builtins.int
    @_builtins.property
    def values(self) -> _containers.MessageMap[_builtins.str, Global___SerializedValue]: ...
    def __init__(
        self,
        *,
        values: _abc.Mapping[_builtins.str, Global___SerializedValue] | None = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["values", b"values"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___InterruptValues: _TypeAlias = InterruptValues  # noqa: Y015

@_typing.final
class Goto(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    NODE_NAME_FIELD_NUMBER: _builtins.int
    SEND_FIELD_NUMBER: _builtins.int
    node_name: _builtins.str
    @_builtins.property
    def send(self) -> Global___Send: ...
    def __init__(
        self,
        *,
        node_name: _builtins.str = ...,
        send: Global___Send | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["message", b"message", "node_name", b"node_name", "send", b"send"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["message", b"message", "node_name", b"node_name", "send", b"send"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType_message: _TypeAlias = _typing.Literal["node_name", "send"]  # noqa: Y015
    _WhichOneofArgType_message: _TypeAlias = _typing.Literal["message", b"message"]  # noqa: Y015
    def WhichOneof(self, oneof_group: _WhichOneofArgType_message) -> _WhichOneofReturnType_message | None: ...

Global___Goto: _TypeAlias = Goto  # noqa: Y015

@_typing.final
class GraphBubbleUp(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

Global___GraphBubbleUp: _TypeAlias = GraphBubbleUp  # noqa: Y015

@_typing.final
class ParentCommand(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    COMMAND_FIELD_NUMBER: _builtins.int
    @_builtins.property
    def command(self) -> Global___Command: ...
    def __init__(
        self,
        *,
        command: Global___Command | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["command", b"command"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["command", b"command"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___ParentCommand: _TypeAlias = ParentCommand  # noqa: Y015

@_typing.final
class GraphInterrupt(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    INTERRUPTS_FIELD_NUMBER: _builtins.int
    @_builtins.property
    def interrupts(self) -> _containers.RepeatedCompositeFieldContainer[Global___Interrupt]: ...
    def __init__(
        self,
        *,
        interrupts: _abc.Iterable[Global___Interrupt] | None = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["interrupts", b"interrupts"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___GraphInterrupt: _TypeAlias = GraphInterrupt  # noqa: Y015

@_typing.final
class Interrupt(_message.Message):
    """Interrupt is a single interrupt from a node execution/task"""

    DESCRIPTOR: _descriptor.Descriptor

    VALUE_FIELD_NUMBER: _builtins.int
    ID_FIELD_NUMBER: _builtins.int
    id: _builtins.str
    @_builtins.property
    def value(self) -> Global___SerializedValue: ...
    def __init__(
        self,
        *,
        value: Global___SerializedValue | None = ...,
        id: _builtins.str = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["value", b"value"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["id", b"id", "value", b"value"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___Interrupt: _TypeAlias = Interrupt  # noqa: Y015

@_typing.final
class WrappedInterrupts(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    INTERRUPTS_FIELD_NUMBER: _builtins.int
    SERIALIZED_INTERRUPTS_FIELD_NUMBER: _builtins.int
    @_builtins.property
    def interrupts(self) -> _containers.RepeatedCompositeFieldContainer[Global___Interrupt]: ...
    @_builtins.property
    def serialized_interrupts(self) -> Global___SerializedValue: ...
    def __init__(
        self,
        *,
        interrupts: _abc.Iterable[Global___Interrupt] | None = ...,
        serialized_interrupts: Global___SerializedValue | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["serialized_interrupts", b"serialized_interrupts"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["interrupts", b"interrupts", "serialized_interrupts", b"serialized_interrupts"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___WrappedInterrupts: _TypeAlias = WrappedInterrupts  # noqa: Y015

@_typing.final
class Write(_message.Message):
    """Writes"""

    DESCRIPTOR: _descriptor.Descriptor

    CHANNEL_FIELD_NUMBER: _builtins.int
    VALUE_FIELD_NUMBER: _builtins.int
    channel: _builtins.str
    @_builtins.property
    def value(self) -> Global___ChannelValue: ...
    def __init__(
        self,
        *,
        channel: _builtins.str = ...,
        value: Global___ChannelValue | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["value", b"value"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["channel", b"channel", "value", b"value"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___Write: _TypeAlias = Write  # noqa: Y015

@_typing.final
class PendingWrite(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    TASK_ID_FIELD_NUMBER: _builtins.int
    CHANNEL_FIELD_NUMBER: _builtins.int
    VALUE_FIELD_NUMBER: _builtins.int
    task_id: _builtins.str
    channel: _builtins.str
    @_builtins.property
    def value(self) -> Global___ChannelValue: ...
    def __init__(
        self,
        *,
        task_id: _builtins.str = ...,
        channel: _builtins.str = ...,
        value: Global___ChannelValue | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["value", b"value"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["channel", b"channel", "task_id", b"task_id", "value", b"value"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___PendingWrite: _TypeAlias = PendingWrite  # noqa: Y015

@_typing.final
class ChannelVersions(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    @_typing.final
    class ChannelVersionsEntry(_message.Message):
        DESCRIPTOR: _descriptor.Descriptor

        KEY_FIELD_NUMBER: _builtins.int
        VALUE_FIELD_NUMBER: _builtins.int
        key: _builtins.str
        value: _builtins.str
        def __init__(
            self,
            *,
            key: _builtins.str = ...,
            value: _builtins.str = ...,
        ) -> None: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal["key", b"key", "value", b"value"]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

    CHANNEL_VERSIONS_FIELD_NUMBER: _builtins.int
    @_builtins.property
    def channel_versions(self) -> _containers.ScalarMap[_builtins.str, _builtins.str]: ...
    def __init__(
        self,
        *,
        channel_versions: _abc.Mapping[_builtins.str, _builtins.str] | None = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["channel_versions", b"channel_versions"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___ChannelVersions: _TypeAlias = ChannelVersions  # noqa: Y015

@_typing.final
class EngineRunnableConfig(_message.Message):
    """A flattened, typed equivalent of OSS RunnableConfig.
    (https://reference.langchain.com/python/langchain_core/runnables/#langchain_core.runnables.RunnableConfig)
    It must be kept isomorphic to the oss variant RunnableConfig if we want to permit it to pass through user apis recursively.
    The RunnableConfig is the omnibus DTO for out-of-band communication in LangChain OSS (and as a consequence, LangGraph).
    It is propagated via context in OSS and persisted (in OSS format) to the database (`run` and `assistants` tables).

    Externally, it has a few jobs to be done:
    1. Tracing configuration: (the run (span) id, run name, tags, & metadata)
    2. Dynamic configuration of user code (to modify how a declarative workflow/object behaves).
    3. Annotating streaming output: all the metadata can be used by middleware and front-end UI's to filter and organize output.

    LangGraph OSS for reasons beyond the scope of this comment also co-opted the `configurable` map for internal book-keeping
    to influence streaming, checkpointing, task management, and other behavior of the graph.
    Some fields provided by the user to stream(), invoke(), etc. are mapped to config values so that they can be accessible from within
    nested graphs and Runnable objects.

    The config is populated in approximately the following precedence (from highest to lowest):
    1. Internal values (resume_map, latest checkpoint_id, etc.) are injected by pregel. (different for each **task**)
    2. Invocation time values in .stream(), .invoke(), etc. (different for each **run**); also from configurable headers, etc..
    3. Configurable values scoped to the **thread**.
    4. Configurable values scoped to the **assistant**.
    5. Defaults (some can be modified via the environment).
    When using this within the engine, always modify via Forking (i.e., do not mutate directly), to ensure
    updates to the config are thread-safe and do not impact other tasks.
    """

    DESCRIPTOR: _descriptor.Descriptor

    @_typing.final
    class MetadataJsonEntry(_message.Message):
        DESCRIPTOR: _descriptor.Descriptor

        KEY_FIELD_NUMBER: _builtins.int
        VALUE_FIELD_NUMBER: _builtins.int
        key: _builtins.str
        value: _builtins.bytes
        def __init__(
            self,
            *,
            key: _builtins.str = ...,
            value: _builtins.bytes = ...,
        ) -> None: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal["key", b"key", "value", b"value"]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

    @_typing.final
    class ExtraConfigurableJsonEntry(_message.Message):
        DESCRIPTOR: _descriptor.Descriptor

        KEY_FIELD_NUMBER: _builtins.int
        VALUE_FIELD_NUMBER: _builtins.int
        key: _builtins.str
        value: _builtins.bytes
        def __init__(
            self,
            *,
            key: _builtins.str = ...,
            value: _builtins.bytes = ...,
        ) -> None: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal["key", b"key", "value", b"value"]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

    @_typing.final
    class ExtraJsonEntry(_message.Message):
        DESCRIPTOR: _descriptor.Descriptor

        KEY_FIELD_NUMBER: _builtins.int
        VALUE_FIELD_NUMBER: _builtins.int
        key: _builtins.str
        value: _builtins.bytes
        def __init__(
            self,
            *,
            key: _builtins.str = ...,
            value: _builtins.bytes = ...,
        ) -> None: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal["key", b"key", "value", b"value"]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

    @_typing.final
    class CheckpointMapEntry(_message.Message):
        DESCRIPTOR: _descriptor.Descriptor

        KEY_FIELD_NUMBER: _builtins.int
        VALUE_FIELD_NUMBER: _builtins.int
        key: _builtins.str
        value: _builtins.str
        def __init__(
            self,
            *,
            key: _builtins.str = ...,
            value: _builtins.str = ...,
        ) -> None: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal["key", b"key", "value", b"value"]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

    @_typing.final
    class ResumeMapEntry(_message.Message):
        DESCRIPTOR: _descriptor.Descriptor

        KEY_FIELD_NUMBER: _builtins.int
        VALUE_FIELD_NUMBER: _builtins.int
        key: _builtins.str
        @_builtins.property
        def value(self) -> Global___SerializedValue: ...
        def __init__(
            self,
            *,
            key: _builtins.str = ...,
            value: Global___SerializedValue | None = ...,
        ) -> None: ...
        _HasFieldArgType: _TypeAlias = _typing.Literal["value", b"value"]  # noqa: Y015
        def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal["key", b"key", "value", b"value"]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

    TAGS_FIELD_NUMBER: _builtins.int
    METADATA_JSON_FIELD_NUMBER: _builtins.int
    RUN_NAME_FIELD_NUMBER: _builtins.int
    MAX_CONCURRENCY_FIELD_NUMBER: _builtins.int
    RECURSION_LIMIT_FIELD_NUMBER: _builtins.int
    RUN_ID_FIELD_NUMBER: _builtins.int
    EXTRA_CONFIGURABLE_JSON_FIELD_NUMBER: _builtins.int
    EXTRA_JSON_FIELD_NUMBER: _builtins.int
    RUNTIME_FIELD_NUMBER: _builtins.int
    RESUMING_FIELD_NUMBER: _builtins.int
    TASK_ID_FIELD_NUMBER: _builtins.int
    THREAD_ID_FIELD_NUMBER: _builtins.int
    CHECKPOINT_MAP_FIELD_NUMBER: _builtins.int
    CHECKPOINT_ID_FIELD_NUMBER: _builtins.int
    CHECKPOINT_NS_FIELD_NUMBER: _builtins.int
    DURABILITY_FIELD_NUMBER: _builtins.int
    RESUME_MAP_FIELD_NUMBER: _builtins.int
    GRAPH_ID_FIELD_NUMBER: _builtins.int
    ROOT_STREAM_MODES_FIELD_NUMBER: _builtins.int
    RUN_ATTEMPT_FIELD_NUMBER: _builtins.int
    SERVER_RUN_ID_FIELD_NUMBER: _builtins.int
    run_name: _builtins.str
    """Tracing run (span) name"""
    max_concurrency: _builtins.int
    """Maximum number of concurrent tasks to support
    This is set by the developer and read by both pregel (engine) and
    in nested Runnable objects that use `.batch()`
    """
    recursion_limit: _builtins.int
    """Maximum number of steps before a recursion error
    This is read by the pregel loop and determines the maximum number of supersteps
    to take before raising a recursion error.
    This is also read by any nested RunnableSequence, etc. objects to limit recursion.
    """
    run_id: _builtins.str
    """The run (span) ID for tracing.
    For our server, this is set by the engine and read by the LangSmith tracer.
    For the first attempt, this run ID is equivalent to the ID of the run in the `run` table.
    For later attempts, this is a randomly generated ID (since it is a new trace).
    """
    resuming: _builtins.bool
    """Whether this execution is resuming an in-progress (interrupted, errored, etc.) run
    (vs. continuing from the start).
    This is an internal flag, written to by the loop (and in OSS it is also written to during a node-local retry).
    This is read by the loop (i.e., in subgraphs) during initialization. If it's set, it takes precedence over the other checks (Command input, etc.).
    In turn, when this is set, the interrupt channel versions of the interrupt channel are advanced to the most recent ones in the checkpoint to avoid
    redundant interrupts.
    Maps to: config.configurable.__pregel_resuming
    """
    task_id: _builtins.str
    """The pregel task ID for this operation.
    This is written to by Pregel (update state op) and read in the
    loop and pregel to see if the invocation is in a nested context.
    Maps to: config.configurable.__pregel_task_id
    """
    thread_id: _builtins.str
    """The thread ID determines how state is tracked across runs (invocations)
    This is set in the public server (when creating the thread and run), though
    it also can be modified in user calls to .invoke().
    When read from the configuration, this is primarily used for trace grouping in langsmith.
    Maps to: config.configurable.thread_id
    """
    checkpoint_id: _builtins.str
    """The specific checkpoint to resume from
    Maps to: config.configurable.checkpoint_id
    """
    checkpoint_ns: _builtins.str
    """The checkpoint namespace tracks the where in a recursive subgraph call
    a particualr checkpoint lives. Primarily written to within pregle/loop.
    Can be provided by the user to control the resume logic.
    Read by the checkpointer for reads/writes.
    This is also a primary component in the inputs to generate the hash for both
    task_id's (above) and interrupt IDs.
    Maps to: config.configurable.checkpoint_ns
    """
    durability: _enum_durability_pb2.Durability.ValueType
    """Specifies how frequently (and with what behavior) checkpoints are saved.
    Default is async (after every superstep but only block at exit or before writing the **next** checkpoint)
    Sync blocks until the checkpoint is saved.
    Exit only saves checkpoints at end of run (including interruptions).
    Maps to: config.configurable.__pregel_durability
    """
    graph_id: _builtins.str
    """The ID of the graph being executed.
    This maps to a registered graph **name** defined in the
    user's langgraph.json configuration file.
    This is set by the main server and read by user code.
    Maps to: config.configurable.graph_id
    """
    run_attempt: _builtins.int
    """**** Note: Typed metadata fields *********************
    The retry attempt for this run. This is populated by our server/engine.
    It is primarily useful for tracing, though it also is accessed in the loop to
    determine if a graph is resuming (during a retry).
    Maps to: config.metadata.run_attempt
    """
    server_run_id: _builtins.str
    """The run from the langgraph runs table. This is equivalent to the tracing run_id if it's the first attempt.
    Maps to: config.metadata.run_id
    ********* End of tracing metadata ********************
    """
    @_builtins.property
    def tags(self) -> _containers.RepeatedScalarFieldContainer[_builtins.str]:
        """Tracing tags. This is written to by the user or within developer code."""

    @_builtins.property
    def metadata_json(self) -> _containers.ScalarMap[_builtins.str, _builtins.bytes]:
        """Tracing metadata (k-v pairs)
        Maps to: config.metadata in OSS
        This is a map (as opposed to bytes) to make it easier to update / merge metadata in the engine
        """

    @_builtins.property
    def extra_configurable_json(self) -> _containers.ScalarMap[_builtins.str, _builtins.bytes]:
        """Custom KV pairs to customize a particular graph.
        Commonly used for personalized prompts, model selection (within init_chat_model, for instance), etc.
        This is the original (legacy, though no deprecation date set) way to dynamically configure an app at runtime.
        The user can write a recursive graph definition and declare values as 'configurable'
         to advertise ways you can adjust runtime behavior.
        This is primarily written to by the user (via run, assistants, configurable headers, etc.)
        This is read by user code.
        Maps to: config.configurable
        This is a map (as opposed to bytes) to make it easier to update / merge configuration in the engine
        """

    @_builtins.property
    def extra_json(self) -> _containers.ScalarMap[_builtins.str, _builtins.bytes]:
        """Any additional top-level fields the user may have provided. These are out of the spec.
        This is a map (as opposed to bytes) to make it easier to update metadata in the engine
        """

    @_builtins.property
    def runtime(self) -> Global___Runtime:
        """******************************************************
        Note: All of the following fields map to specific configurable fields
        in that the OSS implementations of LangGraph consume.
        All configurable values can be read (and depended on) by user code within their graph.
        ******************************************************

        The runtime "context" for a particular execution. After LangGraph 1.0, this has become
        the primary way to define user configuration in a slightly more type-safe way.
        This is read by user code. It can contain arbitrary objects.
        Maps to: config.configurable.__pregel_runtime
        """

    @_builtins.property
    def checkpoint_map(self) -> _containers.ScalarMap[_builtins.str, _builtins.str]:
        """A map of checkpoint namespaces to checkpoint IDs.
        Format: `{checkpoint_ns : checkpoint_id}`. Used to track parent checkpoint IDs
        when executing subgraphs. Useful for building a graph of checkpoint transitions for
        things like time travel.
        Maps to: config.configurable.checkpoint_map
        """

    @_builtins.property
    def resume_map(self) -> _containers.MessageMap[_builtins.str, Global___SerializedValue]:
        """Responses to interrupts by ID. If the user invokes the graph with Command(resume=...),
        we populate the resume_map with the expected data.
        This is read when creating the pregel scratchpad, so if a task that is in an interrupted state receives
        a response, that response is hydrated from this resume map.
        Maps to: config.configurable.__pregel_resume_map
        """

    @_builtins.property
    def root_stream_modes(self) -> _containers.RepeatedScalarFieldContainer[_enum_stream_mode_pb2.StreamMode.ValueType]:
        """Stream modes for the root graph.
        This is set when streaming with stream_subgraphs=True.
        Maps to: config.configurable.__pregel_stream
        ******************************************************
        End of internal configurable fields.
        ******************************************************
        """

    def __init__(
        self,
        *,
        tags: _abc.Iterable[_builtins.str] | None = ...,
        metadata_json: _abc.Mapping[_builtins.str, _builtins.bytes] | None = ...,
        run_name: _builtins.str | None = ...,
        max_concurrency: _builtins.int | None = ...,
        recursion_limit: _builtins.int | None = ...,
        run_id: _builtins.str | None = ...,
        extra_configurable_json: _abc.Mapping[_builtins.str, _builtins.bytes] | None = ...,
        extra_json: _abc.Mapping[_builtins.str, _builtins.bytes] | None = ...,
        runtime: Global___Runtime | None = ...,
        resuming: _builtins.bool | None = ...,
        task_id: _builtins.str | None = ...,
        thread_id: _builtins.str | None = ...,
        checkpoint_map: _abc.Mapping[_builtins.str, _builtins.str] | None = ...,
        checkpoint_id: _builtins.str | None = ...,
        checkpoint_ns: _builtins.str | None = ...,
        durability: _enum_durability_pb2.Durability.ValueType | None = ...,
        resume_map: _abc.Mapping[_builtins.str, Global___SerializedValue] | None = ...,
        graph_id: _builtins.str | None = ...,
        root_stream_modes: _abc.Iterable[_enum_stream_mode_pb2.StreamMode.ValueType] | None = ...,
        run_attempt: _builtins.int | None = ...,
        server_run_id: _builtins.str | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["_checkpoint_id", b"_checkpoint_id", "_checkpoint_ns", b"_checkpoint_ns", "_durability", b"_durability", "_graph_id", b"_graph_id", "_max_concurrency", b"_max_concurrency", "_recursion_limit", b"_recursion_limit", "_resuming", b"_resuming", "_run_attempt", b"_run_attempt", "_run_id", b"_run_id", "_run_name", b"_run_name", "_runtime", b"_runtime", "_server_run_id", b"_server_run_id", "_task_id", b"_task_id", "_thread_id", b"_thread_id", "checkpoint_id", b"checkpoint_id", "checkpoint_ns", b"checkpoint_ns", "durability", b"durability", "graph_id", b"graph_id", "max_concurrency", b"max_concurrency", "recursion_limit", b"recursion_limit", "resuming", b"resuming", "run_attempt", b"run_attempt", "run_id", b"run_id", "run_name", b"run_name", "runtime", b"runtime", "server_run_id", b"server_run_id", "task_id", b"task_id", "thread_id", b"thread_id"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["_checkpoint_id", b"_checkpoint_id", "_checkpoint_ns", b"_checkpoint_ns", "_durability", b"_durability", "_graph_id", b"_graph_id", "_max_concurrency", b"_max_concurrency", "_recursion_limit", b"_recursion_limit", "_resuming", b"_resuming", "_run_attempt", b"_run_attempt", "_run_id", b"_run_id", "_run_name", b"_run_name", "_runtime", b"_runtime", "_server_run_id", b"_server_run_id", "_task_id", b"_task_id", "_thread_id", b"_thread_id", "checkpoint_id", b"checkpoint_id", "checkpoint_map", b"checkpoint_map", "checkpoint_ns", b"checkpoint_ns", "durability", b"durability", "extra_configurable_json", b"extra_configurable_json", "extra_json", b"extra_json", "graph_id", b"graph_id", "max_concurrency", b"max_concurrency", "metadata_json", b"metadata_json", "recursion_limit", b"recursion_limit", "resume_map", b"resume_map", "resuming", b"resuming", "root_stream_modes", b"root_stream_modes", "run_attempt", b"run_attempt", "run_id", b"run_id", "run_name", b"run_name", "runtime", b"runtime", "server_run_id", b"server_run_id", "tags", b"tags", "task_id", b"task_id", "thread_id", b"thread_id"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType__checkpoint_id: _TypeAlias = _typing.Literal["checkpoint_id"]  # noqa: Y015
    _WhichOneofArgType__checkpoint_id: _TypeAlias = _typing.Literal["_checkpoint_id", b"_checkpoint_id"]  # noqa: Y015
    _WhichOneofReturnType__checkpoint_ns: _TypeAlias = _typing.Literal["checkpoint_ns"]  # noqa: Y015
    _WhichOneofArgType__checkpoint_ns: _TypeAlias = _typing.Literal["_checkpoint_ns", b"_checkpoint_ns"]  # noqa: Y015
    _WhichOneofReturnType__durability: _TypeAlias = _typing.Literal["durability"]  # noqa: Y015
    _WhichOneofArgType__durability: _TypeAlias = _typing.Literal["_durability", b"_durability"]  # noqa: Y015
    _WhichOneofReturnType__graph_id: _TypeAlias = _typing.Literal["graph_id"]  # noqa: Y015
    _WhichOneofArgType__graph_id: _TypeAlias = _typing.Literal["_graph_id", b"_graph_id"]  # noqa: Y015
    _WhichOneofReturnType__max_concurrency: _TypeAlias = _typing.Literal["max_concurrency"]  # noqa: Y015
    _WhichOneofArgType__max_concurrency: _TypeAlias = _typing.Literal["_max_concurrency", b"_max_concurrency"]  # noqa: Y015
    _WhichOneofReturnType__recursion_limit: _TypeAlias = _typing.Literal["recursion_limit"]  # noqa: Y015
    _WhichOneofArgType__recursion_limit: _TypeAlias = _typing.Literal["_recursion_limit", b"_recursion_limit"]  # noqa: Y015
    _WhichOneofReturnType__resuming: _TypeAlias = _typing.Literal["resuming"]  # noqa: Y015
    _WhichOneofArgType__resuming: _TypeAlias = _typing.Literal["_resuming", b"_resuming"]  # noqa: Y015
    _WhichOneofReturnType__run_attempt: _TypeAlias = _typing.Literal["run_attempt"]  # noqa: Y015
    _WhichOneofArgType__run_attempt: _TypeAlias = _typing.Literal["_run_attempt", b"_run_attempt"]  # noqa: Y015
    _WhichOneofReturnType__run_id: _TypeAlias = _typing.Literal["run_id"]  # noqa: Y015
    _WhichOneofArgType__run_id: _TypeAlias = _typing.Literal["_run_id", b"_run_id"]  # noqa: Y015
    _WhichOneofReturnType__run_name: _TypeAlias = _typing.Literal["run_name"]  # noqa: Y015
    _WhichOneofArgType__run_name: _TypeAlias = _typing.Literal["_run_name", b"_run_name"]  # noqa: Y015
    _WhichOneofReturnType__runtime: _TypeAlias = _typing.Literal["runtime"]  # noqa: Y015
    _WhichOneofArgType__runtime: _TypeAlias = _typing.Literal["_runtime", b"_runtime"]  # noqa: Y015
    _WhichOneofReturnType__server_run_id: _TypeAlias = _typing.Literal["server_run_id"]  # noqa: Y015
    _WhichOneofArgType__server_run_id: _TypeAlias = _typing.Literal["_server_run_id", b"_server_run_id"]  # noqa: Y015
    _WhichOneofReturnType__task_id: _TypeAlias = _typing.Literal["task_id"]  # noqa: Y015
    _WhichOneofArgType__task_id: _TypeAlias = _typing.Literal["_task_id", b"_task_id"]  # noqa: Y015
    _WhichOneofReturnType__thread_id: _TypeAlias = _typing.Literal["thread_id"]  # noqa: Y015
    _WhichOneofArgType__thread_id: _TypeAlias = _typing.Literal["_thread_id", b"_thread_id"]  # noqa: Y015
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__checkpoint_id) -> _WhichOneofReturnType__checkpoint_id | None: ...
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__checkpoint_ns) -> _WhichOneofReturnType__checkpoint_ns | None: ...
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__durability) -> _WhichOneofReturnType__durability | None: ...
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__graph_id) -> _WhichOneofReturnType__graph_id | None: ...
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__max_concurrency) -> _WhichOneofReturnType__max_concurrency | None: ...
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__recursion_limit) -> _WhichOneofReturnType__recursion_limit | None: ...
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__resuming) -> _WhichOneofReturnType__resuming | None: ...
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__run_attempt) -> _WhichOneofReturnType__run_attempt | None: ...
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__run_id) -> _WhichOneofReturnType__run_id | None: ...
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__run_name) -> _WhichOneofReturnType__run_name | None: ...
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__runtime) -> _WhichOneofReturnType__runtime | None: ...
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__server_run_id) -> _WhichOneofReturnType__server_run_id | None: ...
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__task_id) -> _WhichOneofReturnType__task_id | None: ...
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__thread_id) -> _WhichOneofReturnType__thread_id | None: ...

Global___EngineRunnableConfig: _TypeAlias = EngineRunnableConfig  # noqa: Y015

@_typing.final
class Runtime(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    LANGGRAPH_CONTEXT_JSON_FIELD_NUMBER: _builtins.int
    PREVIOUS_FIELD_NUMBER: _builtins.int
    langgraph_context_json: _builtins.bytes
    """NOTE: only json encoding is supported because this is the encoding in persistence(jsonb column type)"""
    @_builtins.property
    def previous(self) -> Global___ChannelValue:
        """Previous value for functional API's @entrypoint `previous` parameter
        Contains the saved value from prior runs (via entrypoint.final(save=...))
        """

    def __init__(
        self,
        *,
        langgraph_context_json: _builtins.bytes | None = ...,
        previous: Global___ChannelValue | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["_langgraph_context_json", b"_langgraph_context_json", "_previous", b"_previous", "langgraph_context_json", b"langgraph_context_json", "previous", b"previous"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["_langgraph_context_json", b"_langgraph_context_json", "_previous", b"_previous", "langgraph_context_json", b"langgraph_context_json", "previous", b"previous"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType__langgraph_context_json: _TypeAlias = _typing.Literal["langgraph_context_json"]  # noqa: Y015
    _WhichOneofArgType__langgraph_context_json: _TypeAlias = _typing.Literal["_langgraph_context_json", b"_langgraph_context_json"]  # noqa: Y015
    _WhichOneofReturnType__previous: _TypeAlias = _typing.Literal["previous"]  # noqa: Y015
    _WhichOneofArgType__previous: _TypeAlias = _typing.Literal["_previous", b"_previous"]  # noqa: Y015
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__langgraph_context_json) -> _WhichOneofReturnType__langgraph_context_json | None: ...
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__previous) -> _WhichOneofReturnType__previous | None: ...

Global___Runtime: _TypeAlias = Runtime  # noqa: Y015

@_typing.final
class Subgraph(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    GRAPH_ID_FIELD_NUMBER: _builtins.int
    graph_id: _builtins.str
    def __init__(
        self,
        *,
        graph_id: _builtins.str = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["graph_id", b"graph_id"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___Subgraph: _TypeAlias = Subgraph  # noqa: Y015

@_typing.final
class Task(_message.Message):
    """Task
    differentiate between push and pull
    """

    DESCRIPTOR: _descriptor.Descriptor

    NAME_FIELD_NUMBER: _builtins.int
    WRITES_FIELD_NUMBER: _builtins.int
    CONFIG_FIELD_NUMBER: _builtins.int
    TRIGGERS_FIELD_NUMBER: _builtins.int
    ID_FIELD_NUMBER: _builtins.int
    TASK_PATH_FIELD_NUMBER: _builtins.int
    PENDING_WRITES_FIELD_NUMBER: _builtins.int
    STREAM_SUBGRAPHS_FIELD_NUMBER: _builtins.int
    SUBGRAPH_FIELD_NUMBER: _builtins.int
    name: _builtins.str
    id: _builtins.str
    stream_subgraphs: _builtins.bool
    @_builtins.property
    def writes(self) -> _containers.RepeatedCompositeFieldContainer[Global___Write]: ...
    @_builtins.property
    def config(self) -> Global___EngineRunnableConfig: ...
    @_builtins.property
    def triggers(self) -> _containers.RepeatedScalarFieldContainer[_builtins.str]: ...
    @_builtins.property
    def task_path(self) -> _containers.RepeatedCompositeFieldContainer[Global___PathSegment]: ...
    @_builtins.property
    def pending_writes(self) -> _containers.RepeatedCompositeFieldContainer[Global___PendingWrite]: ...
    @_builtins.property
    def subgraph(self) -> Global___Subgraph: ...
    def __init__(
        self,
        *,
        name: _builtins.str = ...,
        writes: _abc.Iterable[Global___Write] | None = ...,
        config: Global___EngineRunnableConfig | None = ...,
        triggers: _abc.Iterable[_builtins.str] | None = ...,
        id: _builtins.str = ...,
        task_path: _abc.Iterable[Global___PathSegment] | None = ...,
        pending_writes: _abc.Iterable[Global___PendingWrite] | None = ...,
        stream_subgraphs: _builtins.bool = ...,
        subgraph: Global___Subgraph | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["_subgraph", b"_subgraph", "config", b"config", "subgraph", b"subgraph"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["_subgraph", b"_subgraph", "config", b"config", "id", b"id", "name", b"name", "pending_writes", b"pending_writes", "stream_subgraphs", b"stream_subgraphs", "subgraph", b"subgraph", "task_path", b"task_path", "triggers", b"triggers", "writes", b"writes"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType__subgraph: _TypeAlias = _typing.Literal["subgraph"]  # noqa: Y015
    _WhichOneofArgType__subgraph: _TypeAlias = _typing.Literal["_subgraph", b"_subgraph"]  # noqa: Y015
    def WhichOneof(self, oneof_group: _WhichOneofArgType__subgraph) -> _WhichOneofReturnType__subgraph | None: ...

Global___Task: _TypeAlias = Task  # noqa: Y015

@_typing.final
class TaskResult(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    USER_ERROR_FIELD_NUMBER: _builtins.int
    INTERRUPTS_FIELD_NUMBER: _builtins.int
    PARENT_COMMAND_FIELD_NUMBER: _builtins.int
    WRITES_FIELD_NUMBER: _builtins.int
    @_builtins.property
    def user_error(self) -> _errors_pb2.UserCodeExecutionError: ...
    @_builtins.property
    def interrupts(self) -> Global___WrappedInterrupts: ...
    @_builtins.property
    def parent_command(self) -> Global___ParentCommand: ...
    @_builtins.property
    def writes(self) -> _containers.RepeatedCompositeFieldContainer[Global___Write]: ...
    def __init__(
        self,
        *,
        user_error: _errors_pb2.UserCodeExecutionError | None = ...,
        interrupts: Global___WrappedInterrupts | None = ...,
        parent_command: Global___ParentCommand | None = ...,
        writes: _abc.Iterable[Global___Write] | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["interrupts", b"interrupts", "message", b"message", "parent_command", b"parent_command", "user_error", b"user_error"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["interrupts", b"interrupts", "message", b"message", "parent_command", b"parent_command", "user_error", b"user_error", "writes", b"writes"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType_message: _TypeAlias = _typing.Literal["user_error", "interrupts", "parent_command"]  # noqa: Y015
    _WhichOneofArgType_message: _TypeAlias = _typing.Literal["message", b"message"]  # noqa: Y015
    def WhichOneof(self, oneof_group: _WhichOneofArgType_message) -> _WhichOneofReturnType_message | None: ...

Global___TaskResult: _TypeAlias = TaskResult  # noqa: Y015

@_typing.final
class CheckpointRef(_message.Message):
    """CheckpointRef is a reference to a checkpoint
    Used to allow checkpoint state lazy loading instead of storing it directly
    """

    DESCRIPTOR: _descriptor.Descriptor

    @_typing.final
    class CheckpointMapEntry(_message.Message):
        DESCRIPTOR: _descriptor.Descriptor

        KEY_FIELD_NUMBER: _builtins.int
        VALUE_FIELD_NUMBER: _builtins.int
        key: _builtins.str
        value: _builtins.str
        def __init__(
            self,
            *,
            key: _builtins.str = ...,
            value: _builtins.str = ...,
        ) -> None: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal["key", b"key", "value", b"value"]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

    CHECKPOINT_ID_FIELD_NUMBER: _builtins.int
    THREAD_ID_FIELD_NUMBER: _builtins.int
    CHECKPOINT_NS_FIELD_NUMBER: _builtins.int
    CHECKPOINT_MAP_FIELD_NUMBER: _builtins.int
    checkpoint_id: _builtins.str
    thread_id: _builtins.str
    checkpoint_ns: _builtins.str
    @_builtins.property
    def checkpoint_map(self) -> _containers.ScalarMap[_builtins.str, _builtins.str]: ...
    def __init__(
        self,
        *,
        checkpoint_id: _builtins.str = ...,
        thread_id: _builtins.str = ...,
        checkpoint_ns: _builtins.str = ...,
        checkpoint_map: _abc.Mapping[_builtins.str, _builtins.str] | None = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["checkpoint_id", b"checkpoint_id", "checkpoint_map", b"checkpoint_map", "checkpoint_ns", b"checkpoint_ns", "thread_id", b"thread_id"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___CheckpointRef: _TypeAlias = CheckpointRef  # noqa: Y015

@_typing.final
class PregelTaskSnapshot(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    ID_FIELD_NUMBER: _builtins.int
    NAME_FIELD_NUMBER: _builtins.int
    PATH_FIELD_NUMBER: _builtins.int
    INTERRUPTS_FIELD_NUMBER: _builtins.int
    RESULT_JSON_FIELD_NUMBER: _builtins.int
    ERROR_FIELD_NUMBER: _builtins.int
    CHECKPOINT_REF_FIELD_NUMBER: _builtins.int
    STATE_SNAPSHOT_FIELD_NUMBER: _builtins.int
    id: _builtins.str
    name: _builtins.str
    result_json: _builtins.bytes
    @_builtins.property
    def path(self) -> _containers.RepeatedCompositeFieldContainer[Global___PathSegment]: ...
    @_builtins.property
    def interrupts(self) -> _containers.RepeatedCompositeFieldContainer[Global___Interrupt]: ...
    @_builtins.property
    def error(self) -> Global___SerializedValue: ...
    @_builtins.property
    def checkpoint_ref(self) -> Global___CheckpointRef: ...
    @_builtins.property
    def state_snapshot(self) -> Global___StateSnapshot: ...
    def __init__(
        self,
        *,
        id: _builtins.str = ...,
        name: _builtins.str = ...,
        path: _abc.Iterable[Global___PathSegment] | None = ...,
        interrupts: _abc.Iterable[Global___Interrupt] | None = ...,
        result_json: _builtins.bytes = ...,
        error: Global___SerializedValue | None = ...,
        checkpoint_ref: Global___CheckpointRef | None = ...,
        state_snapshot: Global___StateSnapshot | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["checkpoint_ref", b"checkpoint_ref", "error", b"error", "state", b"state", "state_snapshot", b"state_snapshot"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["checkpoint_ref", b"checkpoint_ref", "error", b"error", "id", b"id", "interrupts", b"interrupts", "name", b"name", "path", b"path", "result_json", b"result_json", "state", b"state", "state_snapshot", b"state_snapshot"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType_state: _TypeAlias = _typing.Literal["checkpoint_ref", "state_snapshot"]  # noqa: Y015
    _WhichOneofArgType_state: _TypeAlias = _typing.Literal["state", b"state"]  # noqa: Y015
    def WhichOneof(self, oneof_group: _WhichOneofArgType_state) -> _WhichOneofReturnType_state | None: ...

Global___PregelTaskSnapshot: _TypeAlias = PregelTaskSnapshot  # noqa: Y015

@_typing.final
class Checkpoint(_message.Message):
    """Checkpoint"""

    DESCRIPTOR: _descriptor.Descriptor

    @_typing.final
    class ChannelValuesEntry(_message.Message):
        DESCRIPTOR: _descriptor.Descriptor

        KEY_FIELD_NUMBER: _builtins.int
        VALUE_FIELD_NUMBER: _builtins.int
        key: _builtins.str
        @_builtins.property
        def value(self) -> Global___ChannelValue: ...
        def __init__(
            self,
            *,
            key: _builtins.str = ...,
            value: Global___ChannelValue | None = ...,
        ) -> None: ...
        _HasFieldArgType: _TypeAlias = _typing.Literal["value", b"value"]  # noqa: Y015
        def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal["key", b"key", "value", b"value"]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

    @_typing.final
    class ChannelVersionsEntry(_message.Message):
        DESCRIPTOR: _descriptor.Descriptor

        KEY_FIELD_NUMBER: _builtins.int
        VALUE_FIELD_NUMBER: _builtins.int
        key: _builtins.str
        value: _builtins.str
        def __init__(
            self,
            *,
            key: _builtins.str = ...,
            value: _builtins.str = ...,
        ) -> None: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal["key", b"key", "value", b"value"]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

    @_typing.final
    class VersionsSeenEntry(_message.Message):
        DESCRIPTOR: _descriptor.Descriptor

        KEY_FIELD_NUMBER: _builtins.int
        VALUE_FIELD_NUMBER: _builtins.int
        key: _builtins.str
        @_builtins.property
        def value(self) -> Global___ChannelVersions: ...
        def __init__(
            self,
            *,
            key: _builtins.str = ...,
            value: Global___ChannelVersions | None = ...,
        ) -> None: ...
        _HasFieldArgType: _TypeAlias = _typing.Literal["value", b"value"]  # noqa: Y015
        def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal["key", b"key", "value", b"value"]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

    V_FIELD_NUMBER: _builtins.int
    ID_FIELD_NUMBER: _builtins.int
    CHANNEL_VALUES_FIELD_NUMBER: _builtins.int
    CHANNEL_VERSIONS_FIELD_NUMBER: _builtins.int
    VERSIONS_SEEN_FIELD_NUMBER: _builtins.int
    TS_FIELD_NUMBER: _builtins.int
    UPDATED_CHANNELS_FIELD_NUMBER: _builtins.int
    v: _builtins.int
    id: _builtins.str
    ts: _builtins.str
    @_builtins.property
    def channel_values(self) -> _containers.MessageMap[_builtins.str, Global___ChannelValue]: ...
    @_builtins.property
    def channel_versions(self) -> _containers.ScalarMap[_builtins.str, _builtins.str]: ...
    @_builtins.property
    def versions_seen(self) -> _containers.MessageMap[_builtins.str, Global___ChannelVersions]: ...
    @_builtins.property
    def updated_channels(self) -> _containers.RepeatedScalarFieldContainer[_builtins.str]: ...
    def __init__(
        self,
        *,
        v: _builtins.int = ...,
        id: _builtins.str = ...,
        channel_values: _abc.Mapping[_builtins.str, Global___ChannelValue] | None = ...,
        channel_versions: _abc.Mapping[_builtins.str, _builtins.str] | None = ...,
        versions_seen: _abc.Mapping[_builtins.str, Global___ChannelVersions] | None = ...,
        ts: _builtins.str = ...,
        updated_channels: _abc.Iterable[_builtins.str] | None = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["channel_values", b"channel_values", "channel_versions", b"channel_versions", "id", b"id", "ts", b"ts", "updated_channels", b"updated_channels", "v", b"v", "versions_seen", b"versions_seen"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___Checkpoint: _TypeAlias = Checkpoint  # noqa: Y015

@_typing.final
class CheckpointMetadata(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    class _CheckpointSource:
        ValueType = _typing.NewType("ValueType", _builtins.int)
        V: _TypeAlias = ValueType  # noqa: Y015

    class _CheckpointSourceEnumTypeWrapper(_enum_type_wrapper._EnumTypeWrapper[CheckpointMetadata._CheckpointSource.ValueType], _builtins.type):
        DESCRIPTOR: _descriptor.EnumDescriptor
        unknown: CheckpointMetadata._CheckpointSource.ValueType  # 0
        loop: CheckpointMetadata._CheckpointSource.ValueType  # 1
        input: CheckpointMetadata._CheckpointSource.ValueType  # 2
        update: CheckpointMetadata._CheckpointSource.ValueType  # 3
        fork: CheckpointMetadata._CheckpointSource.ValueType  # 4

    class CheckpointSource(_CheckpointSource, metaclass=_CheckpointSourceEnumTypeWrapper): ...
    unknown: CheckpointMetadata.CheckpointSource.ValueType  # 0
    loop: CheckpointMetadata.CheckpointSource.ValueType  # 1
    input: CheckpointMetadata.CheckpointSource.ValueType  # 2
    update: CheckpointMetadata.CheckpointSource.ValueType  # 3
    fork: CheckpointMetadata.CheckpointSource.ValueType  # 4

    @_typing.final
    class ParentsEntry(_message.Message):
        DESCRIPTOR: _descriptor.Descriptor

        KEY_FIELD_NUMBER: _builtins.int
        VALUE_FIELD_NUMBER: _builtins.int
        key: _builtins.str
        value: _builtins.str
        def __init__(
            self,
            *,
            key: _builtins.str = ...,
            value: _builtins.str = ...,
        ) -> None: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal["key", b"key", "value", b"value"]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

    @_typing.final
    class ExtrasEntry(_message.Message):
        DESCRIPTOR: _descriptor.Descriptor

        KEY_FIELD_NUMBER: _builtins.int
        VALUE_FIELD_NUMBER: _builtins.int
        key: _builtins.str
        value: _builtins.bytes
        def __init__(
            self,
            *,
            key: _builtins.str = ...,
            value: _builtins.bytes = ...,
        ) -> None: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal["key", b"key", "value", b"value"]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

    SOURCE_FIELD_NUMBER: _builtins.int
    STEP_FIELD_NUMBER: _builtins.int
    PARENTS_FIELD_NUMBER: _builtins.int
    RUN_ID_FIELD_NUMBER: _builtins.int
    EXTRAS_FIELD_NUMBER: _builtins.int
    source: Global___CheckpointMetadata.CheckpointSource.ValueType
    step: _builtins.int
    run_id: _builtins.str
    @_builtins.property
    def parents(self) -> _containers.ScalarMap[_builtins.str, _builtins.str]: ...
    @_builtins.property
    def extras(self) -> _containers.ScalarMap[_builtins.str, _builtins.bytes]: ...
    def __init__(
        self,
        *,
        source: Global___CheckpointMetadata.CheckpointSource.ValueType = ...,
        step: _builtins.int = ...,
        parents: _abc.Mapping[_builtins.str, _builtins.str] | None = ...,
        run_id: _builtins.str | None = ...,
        extras: _abc.Mapping[_builtins.str, _builtins.bytes] | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["_run_id", b"_run_id", "run_id", b"run_id"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["_run_id", b"_run_id", "extras", b"extras", "parents", b"parents", "run_id", b"run_id", "source", b"source", "step", b"step"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType__run_id: _TypeAlias = _typing.Literal["run_id"]  # noqa: Y015
    _WhichOneofArgType__run_id: _TypeAlias = _typing.Literal["_run_id", b"_run_id"]  # noqa: Y015
    def WhichOneof(self, oneof_group: _WhichOneofArgType__run_id) -> _WhichOneofReturnType__run_id | None: ...

Global___CheckpointMetadata: _TypeAlias = CheckpointMetadata  # noqa: Y015

@_typing.final
class CheckpointTuple(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    CONFIG_FIELD_NUMBER: _builtins.int
    CHECKPOINT_FIELD_NUMBER: _builtins.int
    METADATA_FIELD_NUMBER: _builtins.int
    PARENT_CONFIG_FIELD_NUMBER: _builtins.int
    PENDING_WRITES_FIELD_NUMBER: _builtins.int
    @_builtins.property
    def config(self) -> Global___EngineRunnableConfig: ...
    @_builtins.property
    def checkpoint(self) -> Global___Checkpoint: ...
    @_builtins.property
    def metadata(self) -> Global___CheckpointMetadata: ...
    @_builtins.property
    def parent_config(self) -> Global___EngineRunnableConfig: ...
    @_builtins.property
    def pending_writes(self) -> _containers.RepeatedCompositeFieldContainer[Global___PendingWrite]: ...
    def __init__(
        self,
        *,
        config: Global___EngineRunnableConfig | None = ...,
        checkpoint: Global___Checkpoint | None = ...,
        metadata: Global___CheckpointMetadata | None = ...,
        parent_config: Global___EngineRunnableConfig | None = ...,
        pending_writes: _abc.Iterable[Global___PendingWrite] | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["checkpoint", b"checkpoint", "config", b"config", "metadata", b"metadata", "parent_config", b"parent_config"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["checkpoint", b"checkpoint", "config", b"config", "metadata", b"metadata", "parent_config", b"parent_config", "pending_writes", b"pending_writes"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___CheckpointTuple: _TypeAlias = CheckpointTuple  # noqa: Y015

@_typing.final
class Updates(_message.Message):
    """Updates"""

    DESCRIPTOR: _descriptor.Descriptor

    CHECKPOINT_FIELD_NUMBER: _builtins.int
    CHANNELS_FIELD_NUMBER: _builtins.int
    UPDATED_CHANNELS_FIELD_NUMBER: _builtins.int
    @_builtins.property
    def checkpoint(self) -> Global___Checkpoint: ...
    @_builtins.property
    def channels(self) -> Global___Channels: ...
    @_builtins.property
    def updated_channels(self) -> _containers.RepeatedScalarFieldContainer[_builtins.str]: ...
    def __init__(
        self,
        *,
        checkpoint: Global___Checkpoint | None = ...,
        channels: Global___Channels | None = ...,
        updated_channels: _abc.Iterable[_builtins.str] | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["channels", b"channels", "checkpoint", b"checkpoint"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["channels", b"channels", "checkpoint", b"checkpoint", "updated_channels", b"updated_channels"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___Updates: _TypeAlias = Updates  # noqa: Y015

@_typing.final
class ToolCall(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    NAME_FIELD_NUMBER: _builtins.int
    ARGS_JSON_FIELD_NUMBER: _builtins.int
    ID_FIELD_NUMBER: _builtins.int
    name: _builtins.str
    args_json: _builtins.bytes
    @_builtins.property
    def id(self) -> _wrappers_pb2.StringValue: ...
    def __init__(
        self,
        *,
        name: _builtins.str = ...,
        args_json: _builtins.bytes = ...,
        id: _wrappers_pb2.StringValue | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["id", b"id"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["args_json", b"args_json", "id", b"id", "name", b"name"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___ToolCall: _TypeAlias = ToolCall  # noqa: Y015

@_typing.final
class ToolCallChunk(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    NAME_FIELD_NUMBER: _builtins.int
    ARGS_JSON_FIELD_NUMBER: _builtins.int
    ID_FIELD_NUMBER: _builtins.int
    INDEX_FIELD_NUMBER: _builtins.int
    @_builtins.property
    def name(self) -> _wrappers_pb2.StringValue: ...
    @_builtins.property
    def args_json(self) -> _wrappers_pb2.StringValue: ...
    @_builtins.property
    def id(self) -> _wrappers_pb2.StringValue: ...
    @_builtins.property
    def index(self) -> _wrappers_pb2.Int32Value: ...
    def __init__(
        self,
        *,
        name: _wrappers_pb2.StringValue | None = ...,
        args_json: _wrappers_pb2.StringValue | None = ...,
        id: _wrappers_pb2.StringValue | None = ...,
        index: _wrappers_pb2.Int32Value | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["args_json", b"args_json", "id", b"id", "index", b"index", "name", b"name"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["args_json", b"args_json", "id", b"id", "index", b"index", "name", b"name"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___ToolCallChunk: _TypeAlias = ToolCallChunk  # noqa: Y015

@_typing.final
class InvalidToolCall(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    NAME_FIELD_NUMBER: _builtins.int
    ARGS_FIELD_NUMBER: _builtins.int
    ID_FIELD_NUMBER: _builtins.int
    ERROR_FIELD_NUMBER: _builtins.int
    @_builtins.property
    def name(self) -> _wrappers_pb2.StringValue: ...
    @_builtins.property
    def args(self) -> _wrappers_pb2.StringValue: ...
    @_builtins.property
    def id(self) -> _wrappers_pb2.StringValue: ...
    @_builtins.property
    def error(self) -> _wrappers_pb2.StringValue: ...
    def __init__(
        self,
        *,
        name: _wrappers_pb2.StringValue | None = ...,
        args: _wrappers_pb2.StringValue | None = ...,
        id: _wrappers_pb2.StringValue | None = ...,
        error: _wrappers_pb2.StringValue | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["args", b"args", "error", b"error", "id", b"id", "name", b"name"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["args", b"args", "error", b"error", "id", b"id", "name", b"name"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___InvalidToolCall: _TypeAlias = InvalidToolCall  # noqa: Y015

@_typing.final
class InputTokenDetails(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    AUDIO_FIELD_NUMBER: _builtins.int
    CACHE_CREATION_FIELD_NUMBER: _builtins.int
    CACHE_READ_FIELD_NUMBER: _builtins.int
    @_builtins.property
    def audio(self) -> _wrappers_pb2.Int64Value: ...
    @_builtins.property
    def cache_creation(self) -> _wrappers_pb2.Int64Value: ...
    @_builtins.property
    def cache_read(self) -> _wrappers_pb2.Int64Value: ...
    def __init__(
        self,
        *,
        audio: _wrappers_pb2.Int64Value | None = ...,
        cache_creation: _wrappers_pb2.Int64Value | None = ...,
        cache_read: _wrappers_pb2.Int64Value | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["audio", b"audio", "cache_creation", b"cache_creation", "cache_read", b"cache_read"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["audio", b"audio", "cache_creation", b"cache_creation", "cache_read", b"cache_read"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___InputTokenDetails: _TypeAlias = InputTokenDetails  # noqa: Y015

@_typing.final
class OutputTokenDetails(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    AUDIO_FIELD_NUMBER: _builtins.int
    REASONING_FIELD_NUMBER: _builtins.int
    @_builtins.property
    def audio(self) -> _wrappers_pb2.Int64Value: ...
    @_builtins.property
    def reasoning(self) -> _wrappers_pb2.Int64Value: ...
    def __init__(
        self,
        *,
        audio: _wrappers_pb2.Int64Value | None = ...,
        reasoning: _wrappers_pb2.Int64Value | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["audio", b"audio", "reasoning", b"reasoning"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["audio", b"audio", "reasoning", b"reasoning"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___OutputTokenDetails: _TypeAlias = OutputTokenDetails  # noqa: Y015

@_typing.final
class UsageMetadata(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    INPUT_TOKENS_FIELD_NUMBER: _builtins.int
    OUTPUT_TOKENS_FIELD_NUMBER: _builtins.int
    TOTAL_TOKENS_FIELD_NUMBER: _builtins.int
    INPUT_TOKEN_DETAILS_FIELD_NUMBER: _builtins.int
    OUTPUT_TOKEN_DETAILS_FIELD_NUMBER: _builtins.int
    input_tokens: _builtins.int
    output_tokens: _builtins.int
    total_tokens: _builtins.int
    @_builtins.property
    def input_token_details(self) -> Global___InputTokenDetails: ...
    @_builtins.property
    def output_token_details(self) -> Global___OutputTokenDetails: ...
    def __init__(
        self,
        *,
        input_tokens: _builtins.int = ...,
        output_tokens: _builtins.int = ...,
        total_tokens: _builtins.int = ...,
        input_token_details: Global___InputTokenDetails | None = ...,
        output_token_details: Global___OutputTokenDetails | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["input_token_details", b"input_token_details", "output_token_details", b"output_token_details"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["input_token_details", b"input_token_details", "input_tokens", b"input_tokens", "output_token_details", b"output_token_details", "output_tokens", b"output_tokens", "total_tokens", b"total_tokens"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___UsageMetadata: _TypeAlias = UsageMetadata  # noqa: Y015

@_typing.final
class ResponseMetadata(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    @_typing.final
    class DataEntry(_message.Message):
        DESCRIPTOR: _descriptor.Descriptor

        KEY_FIELD_NUMBER: _builtins.int
        VALUE_FIELD_NUMBER: _builtins.int
        key: _builtins.str
        value: _builtins.bytes
        def __init__(
            self,
            *,
            key: _builtins.str = ...,
            value: _builtins.bytes = ...,
        ) -> None: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal["key", b"key", "value", b"value"]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

    DATA_FIELD_NUMBER: _builtins.int
    @_builtins.property
    def data(self) -> _containers.ScalarMap[_builtins.str, _builtins.bytes]: ...
    def __init__(
        self,
        *,
        data: _abc.Mapping[_builtins.str, _builtins.bytes] | None = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["data", b"data"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___ResponseMetadata: _TypeAlias = ResponseMetadata  # noqa: Y015

@_typing.final
class AIFields(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    USAGE_METADATA_FIELD_NUMBER: _builtins.int
    RESPONSE_METADATA_FIELD_NUMBER: _builtins.int
    TOOL_CALLS_FIELD_NUMBER: _builtins.int
    TOOL_CALL_CHUNKS_FIELD_NUMBER: _builtins.int
    INVALID_TOOL_CALLS_FIELD_NUMBER: _builtins.int
    CHUNK_POSITION_FIELD_NUMBER: _builtins.int
    REASONING_CONTENT_FIELD_NUMBER: _builtins.int
    chunk_position: _builtins.str
    @_builtins.property
    def usage_metadata(self) -> Global___UsageMetadata: ...
    @_builtins.property
    def response_metadata(self) -> Global___ResponseMetadata: ...
    @_builtins.property
    def tool_calls(self) -> _containers.RepeatedCompositeFieldContainer[Global___ToolCall]: ...
    @_builtins.property
    def tool_call_chunks(self) -> _containers.RepeatedCompositeFieldContainer[Global___ToolCallChunk]: ...
    @_builtins.property
    def invalid_tool_calls(self) -> _containers.RepeatedCompositeFieldContainer[Global___InvalidToolCall]: ...
    @_builtins.property
    def reasoning_content(self) -> _wrappers_pb2.StringValue:
        """Optional standardized reasoning hook you already surface in additional_kwargs."""

    def __init__(
        self,
        *,
        usage_metadata: Global___UsageMetadata | None = ...,
        response_metadata: Global___ResponseMetadata | None = ...,
        tool_calls: _abc.Iterable[Global___ToolCall] | None = ...,
        tool_call_chunks: _abc.Iterable[Global___ToolCallChunk] | None = ...,
        invalid_tool_calls: _abc.Iterable[Global___InvalidToolCall] | None = ...,
        chunk_position: _builtins.str | None = ...,
        reasoning_content: _wrappers_pb2.StringValue | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["_chunk_position", b"_chunk_position", "_response_metadata", b"_response_metadata", "_usage_metadata", b"_usage_metadata", "chunk_position", b"chunk_position", "reasoning_content", b"reasoning_content", "response_metadata", b"response_metadata", "usage_metadata", b"usage_metadata"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["_chunk_position", b"_chunk_position", "_response_metadata", b"_response_metadata", "_usage_metadata", b"_usage_metadata", "chunk_position", b"chunk_position", "invalid_tool_calls", b"invalid_tool_calls", "reasoning_content", b"reasoning_content", "response_metadata", b"response_metadata", "tool_call_chunks", b"tool_call_chunks", "tool_calls", b"tool_calls", "usage_metadata", b"usage_metadata"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType__chunk_position: _TypeAlias = _typing.Literal["chunk_position"]  # noqa: Y015
    _WhichOneofArgType__chunk_position: _TypeAlias = _typing.Literal["_chunk_position", b"_chunk_position"]  # noqa: Y015
    _WhichOneofReturnType__response_metadata: _TypeAlias = _typing.Literal["response_metadata"]  # noqa: Y015
    _WhichOneofArgType__response_metadata: _TypeAlias = _typing.Literal["_response_metadata", b"_response_metadata"]  # noqa: Y015
    _WhichOneofReturnType__usage_metadata: _TypeAlias = _typing.Literal["usage_metadata"]  # noqa: Y015
    _WhichOneofArgType__usage_metadata: _TypeAlias = _typing.Literal["_usage_metadata", b"_usage_metadata"]  # noqa: Y015
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__chunk_position) -> _WhichOneofReturnType__chunk_position | None: ...
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__response_metadata) -> _WhichOneofReturnType__response_metadata | None: ...
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__usage_metadata) -> _WhichOneofReturnType__usage_metadata | None: ...

Global___AIFields: _TypeAlias = AIFields  # noqa: Y015

@_typing.final
class ToolFields(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    TOOL_CALL_ID_FIELD_NUMBER: _builtins.int
    STATUS_FIELD_NUMBER: _builtins.int
    ARTIFACT_FIELD_NUMBER: _builtins.int
    status: _builtins.str
    @_builtins.property
    def tool_call_id(self) -> _wrappers_pb2.StringValue: ...
    @_builtins.property
    def artifact(self) -> Global___SerializedValue: ...
    def __init__(
        self,
        *,
        tool_call_id: _wrappers_pb2.StringValue | None = ...,
        status: _builtins.str = ...,
        artifact: Global___SerializedValue | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["_artifact", b"_artifact", "artifact", b"artifact", "tool_call_id", b"tool_call_id"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["_artifact", b"_artifact", "artifact", b"artifact", "status", b"status", "tool_call_id", b"tool_call_id"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType__artifact: _TypeAlias = _typing.Literal["artifact"]  # noqa: Y015
    _WhichOneofArgType__artifact: _TypeAlias = _typing.Literal["_artifact", b"_artifact"]  # noqa: Y015
    def WhichOneof(self, oneof_group: _WhichOneofArgType__artifact) -> _WhichOneofReturnType__artifact | None: ...

Global___ToolFields: _TypeAlias = ToolFields  # noqa: Y015

@_typing.final
class HumanFields(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

Global___HumanFields: _TypeAlias = HumanFields  # noqa: Y015

@_typing.final
class Content(_message.Message):
    """Content represents message content: str | list[str | dict]"""

    DESCRIPTOR: _descriptor.Descriptor

    TEXT_FIELD_NUMBER: _builtins.int
    BLOCKS_FIELD_NUMBER: _builtins.int
    text: _builtins.str
    """Simple string content"""
    @_builtins.property
    def blocks(self) -> Global___ContentBlocks:
        """List of content blocks (multimodal content)"""

    def __init__(
        self,
        *,
        text: _builtins.str = ...,
        blocks: Global___ContentBlocks | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["blocks", b"blocks", "content", b"content", "text", b"text"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["blocks", b"blocks", "content", b"content", "text", b"text"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType_content: _TypeAlias = _typing.Literal["text", "blocks"]  # noqa: Y015
    _WhichOneofArgType_content: _TypeAlias = _typing.Literal["content", b"content"]  # noqa: Y015
    def WhichOneof(self, oneof_group: _WhichOneofArgType_content) -> _WhichOneofReturnType_content | None: ...

Global___Content: _TypeAlias = Content  # noqa: Y015

@_typing.final
class ContentBlocks(_message.Message):
    """ContentBlocks is a list of content blocks"""

    DESCRIPTOR: _descriptor.Descriptor

    ITEMS_FIELD_NUMBER: _builtins.int
    @_builtins.property
    def items(self) -> _containers.RepeatedCompositeFieldContainer[Global___ContentBlock]: ...
    def __init__(
        self,
        *,
        items: _abc.Iterable[Global___ContentBlock] | None = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["items", b"items"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___ContentBlocks: _TypeAlias = ContentBlocks  # noqa: Y015

@_typing.final
class ContentBlock(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    TEXT_FIELD_NUMBER: _builtins.int
    STRUCTURED_FIELD_NUMBER: _builtins.int
    text: _builtins.str
    @_builtins.property
    def structured(self) -> Global___StructuredBlock: ...
    def __init__(
        self,
        *,
        text: _builtins.str = ...,
        structured: Global___StructuredBlock | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["data", b"data", "structured", b"structured", "text", b"text"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["data", b"data", "structured", b"structured", "text", b"text"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType_data: _TypeAlias = _typing.Literal["text", "structured"]  # noqa: Y015
    _WhichOneofArgType_data: _TypeAlias = _typing.Literal["data", b"data"]  # noqa: Y015
    def WhichOneof(self, oneof_group: _WhichOneofArgType_data) -> _WhichOneofReturnType_data | None: ...

Global___ContentBlock: _TypeAlias = ContentBlock  # noqa: Y015

@_typing.final
class StructuredBlock(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    INDEX_FIELD_NUMBER: _builtins.int
    TYPE_FIELD_NUMBER: _builtins.int
    DATA_JSON_FIELD_NUMBER: _builtins.int
    index: _builtins.int
    type: _builtins.str
    data_json: _builtins.bytes
    """Full content as JSON (includes index/type for completeness)"""
    def __init__(
        self,
        *,
        index: _builtins.int | None = ...,
        type: _builtins.str | None = ...,
        data_json: _builtins.bytes = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["_index", b"_index", "_type", b"_type", "index", b"index", "type", b"type"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["_index", b"_index", "_type", b"_type", "data_json", b"data_json", "index", b"index", "type", b"type"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType__index: _TypeAlias = _typing.Literal["index"]  # noqa: Y015
    _WhichOneofArgType__index: _TypeAlias = _typing.Literal["_index", b"_index"]  # noqa: Y015
    _WhichOneofReturnType__type: _TypeAlias = _typing.Literal["type"]  # noqa: Y015
    _WhichOneofArgType__type: _TypeAlias = _typing.Literal["_type", b"_type"]  # noqa: Y015
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__index) -> _WhichOneofReturnType__index | None: ...
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__type) -> _WhichOneofReturnType__type | None: ...

Global___StructuredBlock: _TypeAlias = StructuredBlock  # noqa: Y015

@_typing.final
class ChatMessage(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    @_typing.final
    class AdditionalKwargsEntry(_message.Message):
        DESCRIPTOR: _descriptor.Descriptor

        KEY_FIELD_NUMBER: _builtins.int
        VALUE_FIELD_NUMBER: _builtins.int
        key: _builtins.str
        value: _builtins.bytes
        def __init__(
            self,
            *,
            key: _builtins.str = ...,
            value: _builtins.bytes = ...,
        ) -> None: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal["key", b"key", "value", b"value"]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

    @_typing.final
    class ExtensionsEntry(_message.Message):
        DESCRIPTOR: _descriptor.Descriptor

        KEY_FIELD_NUMBER: _builtins.int
        VALUE_FIELD_NUMBER: _builtins.int
        key: _builtins.str
        value: _builtins.bytes
        def __init__(
            self,
            *,
            key: _builtins.str = ...,
            value: _builtins.bytes = ...,
        ) -> None: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal["key", b"key", "value", b"value"]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

    ID_FIELD_NUMBER: _builtins.int
    NAME_FIELD_NUMBER: _builtins.int
    TYPE_FIELD_NUMBER: _builtins.int
    CONTENT_FIELD_NUMBER: _builtins.int
    ADDITIONAL_KWARGS_FIELD_NUMBER: _builtins.int
    AI_FIELD_NUMBER: _builtins.int
    TOOL_FIELD_NUMBER: _builtins.int
    HUMAN_FIELD_NUMBER: _builtins.int
    EXTENSIONS_FIELD_NUMBER: _builtins.int
    id: _builtins.str
    name: _builtins.str
    type: _builtins.str
    @_builtins.property
    def content(self) -> Global___Content: ...
    @_builtins.property
    def additional_kwargs(self) -> _containers.ScalarMap[_builtins.str, _builtins.bytes]: ...
    @_builtins.property
    def ai(self) -> Global___AIFields: ...
    @_builtins.property
    def tool(self) -> Global___ToolFields: ...
    @_builtins.property
    def human(self) -> Global___HumanFields: ...
    @_builtins.property
    def extensions(self) -> _containers.ScalarMap[_builtins.str, _builtins.bytes]:
        """Additional user-added fields that are to be flattened at message root when
        deserializing in the target user language.
        """

    def __init__(
        self,
        *,
        id: _builtins.str = ...,
        name: _builtins.str = ...,
        type: _builtins.str = ...,
        content: Global___Content | None = ...,
        additional_kwargs: _abc.Mapping[_builtins.str, _builtins.bytes] | None = ...,
        ai: Global___AIFields | None = ...,
        tool: Global___ToolFields | None = ...,
        human: Global___HumanFields | None = ...,
        extensions: _abc.Mapping[_builtins.str, _builtins.bytes] | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["ai", b"ai", "content", b"content", "details", b"details", "human", b"human", "tool", b"tool"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["additional_kwargs", b"additional_kwargs", "ai", b"ai", "content", b"content", "details", b"details", "extensions", b"extensions", "human", b"human", "id", b"id", "name", b"name", "tool", b"tool", "type", b"type"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType_details: _TypeAlias = _typing.Literal["ai", "tool", "human"]  # noqa: Y015
    _WhichOneofArgType_details: _TypeAlias = _typing.Literal["details", b"details"]  # noqa: Y015
    def WhichOneof(self, oneof_group: _WhichOneofArgType_details) -> _WhichOneofReturnType_details | None: ...

Global___ChatMessage: _TypeAlias = ChatMessage  # noqa: Y015

@_typing.final
class ChatMessageEnvelope(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    IS_STREAMING_CHUNK_FIELD_NUMBER: _builtins.int
    NAMESPACE_FIELD_NUMBER: _builtins.int
    MESSAGE_FIELD_NUMBER: _builtins.int
    METADATA_FIELD_NUMBER: _builtins.int
    NODE_NAME_FIELD_NUMBER: _builtins.int
    is_streaming_chunk: _builtins.bool
    metadata: _builtins.bytes
    node_name: _builtins.str
    @_builtins.property
    def namespace(self) -> _containers.RepeatedScalarFieldContainer[_builtins.str]: ...
    @_builtins.property
    def message(self) -> Global___ChatMessage: ...
    def __init__(
        self,
        *,
        is_streaming_chunk: _builtins.bool = ...,
        namespace: _abc.Iterable[_builtins.str] | None = ...,
        message: Global___ChatMessage | None = ...,
        metadata: _builtins.bytes | None = ...,
        node_name: _builtins.str | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["_metadata", b"_metadata", "_node_name", b"_node_name", "message", b"message", "metadata", b"metadata", "node_name", b"node_name"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["_metadata", b"_metadata", "_node_name", b"_node_name", "is_streaming_chunk", b"is_streaming_chunk", "message", b"message", "metadata", b"metadata", "namespace", b"namespace", "node_name", b"node_name"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType__metadata: _TypeAlias = _typing.Literal["metadata"]  # noqa: Y015
    _WhichOneofArgType__metadata: _TypeAlias = _typing.Literal["_metadata", b"_metadata"]  # noqa: Y015
    _WhichOneofReturnType__node_name: _TypeAlias = _typing.Literal["node_name"]  # noqa: Y015
    _WhichOneofArgType__node_name: _TypeAlias = _typing.Literal["_node_name", b"_node_name"]  # noqa: Y015
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__metadata) -> _WhichOneofReturnType__metadata | None: ...
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__node_name) -> _WhichOneofReturnType__node_name | None: ...

Global___ChatMessageEnvelope: _TypeAlias = ChatMessageEnvelope  # noqa: Y015

@_typing.final
class StateSnapshot(_message.Message):
    """StateSnapshot"""

    DESCRIPTOR: _descriptor.Descriptor

    VALUES_JSON_FIELD_NUMBER: _builtins.int
    NEXT_FIELD_NUMBER: _builtins.int
    CONFIG_FIELD_NUMBER: _builtins.int
    METADATA_FIELD_NUMBER: _builtins.int
    CREATED_AT_FIELD_NUMBER: _builtins.int
    PARENT_CONFIG_FIELD_NUMBER: _builtins.int
    TASKS_FIELD_NUMBER: _builtins.int
    INTERRUPTS_FIELD_NUMBER: _builtins.int
    values_json: _builtins.bytes
    created_at: _builtins.str
    @_builtins.property
    def next(self) -> _containers.RepeatedScalarFieldContainer[_builtins.str]: ...
    @_builtins.property
    def config(self) -> Global___EngineRunnableConfig: ...
    @_builtins.property
    def metadata(self) -> Global___CheckpointMetadata: ...
    @_builtins.property
    def parent_config(self) -> Global___EngineRunnableConfig: ...
    @_builtins.property
    def tasks(self) -> _containers.RepeatedCompositeFieldContainer[Global___PregelTaskSnapshot]: ...
    @_builtins.property
    def interrupts(self) -> _containers.RepeatedCompositeFieldContainer[Global___Interrupt]: ...
    def __init__(
        self,
        *,
        values_json: _builtins.bytes = ...,
        next: _abc.Iterable[_builtins.str] | None = ...,
        config: Global___EngineRunnableConfig | None = ...,
        metadata: Global___CheckpointMetadata | None = ...,
        created_at: _builtins.str | None = ...,
        parent_config: Global___EngineRunnableConfig | None = ...,
        tasks: _abc.Iterable[Global___PregelTaskSnapshot] | None = ...,
        interrupts: _abc.Iterable[Global___Interrupt] | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["_created_at", b"_created_at", "_metadata", b"_metadata", "_parent_config", b"_parent_config", "config", b"config", "created_at", b"created_at", "metadata", b"metadata", "parent_config", b"parent_config"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["_created_at", b"_created_at", "_metadata", b"_metadata", "_parent_config", b"_parent_config", "config", b"config", "created_at", b"created_at", "interrupts", b"interrupts", "metadata", b"metadata", "next", b"next", "parent_config", b"parent_config", "tasks", b"tasks", "values_json", b"values_json"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType__created_at: _TypeAlias = _typing.Literal["created_at"]  # noqa: Y015
    _WhichOneofArgType__created_at: _TypeAlias = _typing.Literal["_created_at", b"_created_at"]  # noqa: Y015
    _WhichOneofReturnType__metadata: _TypeAlias = _typing.Literal["metadata"]  # noqa: Y015
    _WhichOneofArgType__metadata: _TypeAlias = _typing.Literal["_metadata", b"_metadata"]  # noqa: Y015
    _WhichOneofReturnType__parent_config: _TypeAlias = _typing.Literal["parent_config"]  # noqa: Y015
    _WhichOneofArgType__parent_config: _TypeAlias = _typing.Literal["_parent_config", b"_parent_config"]  # noqa: Y015
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__created_at) -> _WhichOneofReturnType__created_at | None: ...
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__metadata) -> _WhichOneofReturnType__metadata | None: ...
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__parent_config) -> _WhichOneofReturnType__parent_config | None: ...

Global___StateSnapshot: _TypeAlias = StateSnapshot  # noqa: Y015

@_typing.final
class StateUpdate(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    VALUES_FIELD_NUMBER: _builtins.int
    AS_NODE_FIELD_NUMBER: _builtins.int
    TASK_ID_FIELD_NUMBER: _builtins.int
    as_node: _builtins.str
    task_id: _builtins.str
    @_builtins.property
    def values(self) -> Global___SerializedValue: ...
    def __init__(
        self,
        *,
        values: Global___SerializedValue | None = ...,
        as_node: _builtins.str | None = ...,
        task_id: _builtins.str | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["_as_node", b"_as_node", "_task_id", b"_task_id", "as_node", b"as_node", "task_id", b"task_id", "values", b"values"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["_as_node", b"_as_node", "_task_id", b"_task_id", "as_node", b"as_node", "task_id", b"task_id", "values", b"values"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType__as_node: _TypeAlias = _typing.Literal["as_node"]  # noqa: Y015
    _WhichOneofArgType__as_node: _TypeAlias = _typing.Literal["_as_node", b"_as_node"]  # noqa: Y015
    _WhichOneofReturnType__task_id: _TypeAlias = _typing.Literal["task_id"]  # noqa: Y015
    _WhichOneofArgType__task_id: _TypeAlias = _typing.Literal["_task_id", b"_task_id"]  # noqa: Y015
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__as_node) -> _WhichOneofReturnType__as_node | None: ...
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__task_id) -> _WhichOneofReturnType__task_id | None: ...

Global___StateUpdate: _TypeAlias = StateUpdate  # noqa: Y015

@_typing.final
class SuperstepUpdates(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    UPDATES_FIELD_NUMBER: _builtins.int
    @_builtins.property
    def updates(self) -> _containers.RepeatedCompositeFieldContainer[Global___StateUpdate]: ...
    def __init__(
        self,
        *,
        updates: _abc.Iterable[Global___StateUpdate] | None = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["updates", b"updates"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___SuperstepUpdates: _TypeAlias = SuperstepUpdates  # noqa: Y015

@_typing.final
class StringOrSlice(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    VALUES_FIELD_NUMBER: _builtins.int
    IS_STRING_FIELD_NUMBER: _builtins.int
    is_string: _builtins.bool
    @_builtins.property
    def values(self) -> _containers.RepeatedScalarFieldContainer[_builtins.str]: ...
    def __init__(
        self,
        *,
        values: _abc.Iterable[_builtins.str] | None = ...,
        is_string: _builtins.bool = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["is_string", b"is_string", "values", b"values"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___StringOrSlice: _TypeAlias = StringOrSlice  # noqa: Y015

@_typing.final
class PathSegment(_message.Message):
    """PathSegment represents one element in a PregelTask's 'task_path'.

    Task paths track the hierarchical location of a task as it traverses through parent graphs
    and subgraphs. Each segment can be:
    - string_value: operation types (like "__pregel_push" or "__pregel_pull") or node names
    - int_value: index of the send (if emitting multiple sends in a superstep)
    - bool_value: flags indicating execution context (true for Call tasks, false for Send tasks)

    The bool at the end of the task path indicates whether or not a "call" was present in this
    task (in the engine case, we never do, since we don't distribute functional API tasks).
    This helps us deduplicate interrupt emission in cases where multiple functional API tasks are run in a node.
    - True -> "Call is being made" -> don't emit interrupts because they will be emitted by the parent.
    - False -> "Call is not being made" -> emit interrupts
    See: https://github.com/langchain-ai/langgraph/pull/4389/files for more info.

    Some example task paths:
      - Root PUSH task (from Send): ["PUSH", 0, false]
        * "PUSH": operation type
        * 0: index of the Send in the TASKS channel

      - Root PULL task: ["PULL", "node_name"]
        * "PULL": operation type
        * "node_name": target node name

      - Nested subgraph via Call: ["PUSH", parent_task_path, write_idx, parent_task_id, Call_object, true]
        * The parent's task path is embedded as a segment (e.g., ("PULL", "parent_node"))
        * write_idx: index of the Call write
        * parent_task_id: ID of the parent task that made the Call
        * true: this is a Call task, interrupts are handled by parent

    The full task_path is also an input to the consistent hash to generate the task ID and interrupt ID (if any).
    """

    DESCRIPTOR: _descriptor.Descriptor

    STRING_VALUE_FIELD_NUMBER: _builtins.int
    INT_VALUE_FIELD_NUMBER: _builtins.int
    BOOL_VALUE_FIELD_NUMBER: _builtins.int
    string_value: _builtins.str
    int_value: _builtins.int
    bool_value: _builtins.bool
    def __init__(
        self,
        *,
        string_value: _builtins.str = ...,
        int_value: _builtins.int = ...,
        bool_value: _builtins.bool = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["bool_value", b"bool_value", "int_value", b"int_value", "string_value", b"string_value", "value", b"value"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["bool_value", b"bool_value", "int_value", b"int_value", "string_value", b"string_value", "value", b"value"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType_value: _TypeAlias = _typing.Literal["string_value", "int_value", "bool_value"]  # noqa: Y015
    _WhichOneofArgType_value: _TypeAlias = _typing.Literal["value", b"value"]  # noqa: Y015
    def WhichOneof(self, oneof_group: _WhichOneofArgType_value) -> _WhichOneofReturnType_value | None: ...

Global___PathSegment: _TypeAlias = PathSegment  # noqa: Y015

@_typing.final
class StaticInterruptConfig(_message.Message):
    """StaticInterruptConfig specifies which nodes to interrupt at (compile-time configuration).
    This is the graph-level interrupt configuration (interrupt_before/interrupt_after)
    that specifies which nodes can trigger interrupts, not runtime interrupt values.
    Uses a oneof to represent three mutually exclusive cases:
    - If the field is not set (null/None), no interrupts occur (default).
    - If all is set (to true), interrupt at all nodes (equivalent to "*").
    - If node_names is set, interrupt only at the specified nodes.
    """

    DESCRIPTOR: _descriptor.Descriptor

    @_typing.final
    class NodeNames(_message.Message):
        DESCRIPTOR: _descriptor.Descriptor

        NAMES_FIELD_NUMBER: _builtins.int
        @_builtins.property
        def names(self) -> _containers.RepeatedScalarFieldContainer[_builtins.str]: ...
        def __init__(
            self,
            *,
            names: _abc.Iterable[_builtins.str] | None = ...,
        ) -> None: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal["names", b"names"]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

    ALL_FIELD_NUMBER: _builtins.int
    NODE_NAMES_FIELD_NUMBER: _builtins.int
    all: _builtins.bool
    @_builtins.property
    def node_names(self) -> Global___StaticInterruptConfig.NodeNames: ...
    def __init__(
        self,
        *,
        all: _builtins.bool = ...,
        node_names: Global___StaticInterruptConfig.NodeNames | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["all", b"all", "config", b"config", "node_names", b"node_names"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["all", b"all", "config", b"config", "node_names", b"node_names"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType_config: _TypeAlias = _typing.Literal["all", "node_names"]  # noqa: Y015
    _WhichOneofArgType_config: _TypeAlias = _typing.Literal["config", b"config"]  # noqa: Y015
    def WhichOneof(self, oneof_group: _WhichOneofArgType_config) -> _WhichOneofReturnType_config | None: ...

Global___StaticInterruptConfig: _TypeAlias = StaticInterruptConfig  # noqa: Y015
